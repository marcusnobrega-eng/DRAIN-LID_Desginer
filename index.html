<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DRAIN-LID Design Performance Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <!-- MathJax JUST for the soil-parameter line -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  <style>
    :root {
      --bg: #ffffff;
      --fg: #222222;
      --accent: #1f77b4;
      --muted: #777777;
      --border: #dddddd;
      --panel-bg: #f8f8f8;
      --font-main: "Palatino Linotype", "Book Antiqua", Palatino, "Times New Roman", serif;
    }
    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 1.5rem;
      font-family: var(--font-main);
      background: var(--bg);
      color: var(--fg);
    }

    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }

    h1 {
      font-size: 1.6rem;
      margin: 0;
    }

    .subtitle {
      margin: 0.15rem 0 0 0;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .logo-box img {
      max-height: 64px;
      width: auto;
      display: block;
    }

    .soil-params-wrapper {
      margin: 0.25rem 0 0.75rem 0;
      padding: 0.4rem 0.75rem;
      border-radius: 0.5rem;
      background: #fbfbfb;
      border: 1px solid #eeeeee;
      font-size: 0.95rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 0.9rem;
      margin-bottom: 1rem;
      background: var(--panel-bg);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      min-width: 200px;
    }

    .control-group label {
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
      color: var(--muted);
    }

    select {
      padding: 0.35rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      font-size: 0.9rem;
      background: #fff;
      cursor: pointer;
    }

    select:disabled {
      background: #f0f0f0;
      cursor: not-allowed;
      color: #aaaaaa;
    }

    .plots-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    .plot-panel {
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.25rem;
      background: #ffffff;
    }

    .plot-div {
      width: 100%;
      height: 360px;
    }

    .hydro-panel {
      margin-top: 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.5rem 0.75rem 0.75rem 0.75rem;
      background: #ffffff;
    }

    #hydro-plot {
      width: 100%;
      height: 260px;
    }

    .hydro-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.25rem;
    }

    .status {
      margin-top: 0.35rem;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .status.error {
      color: #b00020;
    }

    .legend-note {
      margin-top: 0.4rem;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .about-box {
      margin-top: 1.0rem;
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.4;
    }

    .about-box strong {
      color: #444;
    }

    button {
      padding: 0.3rem 0.7rem;
      font-size: 0.8rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: #f4f4f4;
      cursor: pointer;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div class="page-header">
    <div>
      <h1>DRAIN-LID Design Performance Explorer</h1>
      <p class="subtitle">
        Interactive design-space visualization from the DRAIN-LID database
      </p>
    </div>
    <div class="logo-box" id="logo-box">
      <!-- Logo gets injected here if LOGO_URL is set in JS -->
    </div>
  </div>

  <div class="soil-params-wrapper">
    <span id="soil-params">
      <!-- Filled by JS, rendered with MathJax -->
    </span>
  </div>

  <div class="controls">
    <div class="control-group">
      <label for="soil-select">Soil type</label>
      <select id="soil-select" disabled></select>
    </div>

    <div class="control-group">
      <label for="peff-select">Effective precipitation, P<sub>eff</sub></label>
      <select id="peff-select" disabled></select>
    </div>
  </div>

  <div class="plots-row">
    <div class="plot-panel">
      <div id="plot-eta" class="plot-div"></div>
    </div>
    <div class="plot-panel">
      <div id="plot-det" class="plot-div"></div>
    </div>
    <div class="plot-panel">
      <div id="plot-dtp" class="plot-div"></div>
    </div>
  </div>

  <div class="hydro-panel">
    <div class="hydro-header">
      <div id="hydro-title">Hydrographs — no scenario selected yet</div>
      <button id="btn-download" disabled>Download CSV</button>
    </div>
    <div id="hydro-plot"></div>
    <div id="status" class="status">Loading data…</div>
    <div class="legend-note">
      Markers with outline only correspond to designs for which the solver
      failed or violated ponding constraints. Hydrographs are shown in
      normalized flux units (mm/h) over the LID surface. Due to size limitations, only solutions with peak flow reductions of 20-50% are shown for the first 24h, although the model is run for 48h.
    </div>
  </div>

  <div class="about-box">
    <p>
      <strong>About this explorer.</strong>
      This interactive tool was developed by Marcus N. Gomes Jr., PhD, to
      visualize the design space of infiltration-based Low Impact Development
      systems simulated with the DRAIN-LID model. Each point represents a
      numerical solution of a mixed-form Richards equation coupled to a
      structural drainage module under a specified inflow hydrograph and media
      configuration. The area-ratio axis shows the ratio between the LID
      surface and the contributing catchment area.
    </p>
  </div>

  <script>
    // ========= CONFIG =======================================================
    const DATA_URL = 'drain_lid_database.json';
    const LOGO_URL = 'drainlid_logo.png'; // e.g. 'drainlid_logo.png' (leave '' if none)

    // Hard-coded van Genuchten–Mualem parameters (Carsel & Parrish, 1988)
    // alpha [1/m], Ks_mm_per_h [mm/h], theta_r, theta_s [-]
    const SOIL_PROPS = {
      "Sand":          { theta_r: 0.045, theta_s: 0.43, alpha: 14.5, n: 2.68, Ks_mm_per_h: 297.0 },
      "Loamy Sand":    { theta_r: 0.057, theta_s: 0.41, alpha: 12.4, n: 2.28, Ks_mm_per_h: 145.8 },
      "Sandy Loam":    { theta_r: 0.065, theta_s: 0.41, alpha: 7.5,  n: 1.89, Ks_mm_per_h: 44.3  },
      "Loam":          { theta_r: 0.078, theta_s: 0.43, alpha: 3.6,  n: 1.56, Ks_mm_per_h: 10.4  },
      "Silt":          { theta_r: 0.034, theta_s: 0.46, alpha: 1.6,  n: 1.37, Ks_mm_per_h: 2.5   },
      "Silty Loam":    { theta_r: 0.067, theta_s: 0.45, alpha: 2.0,  n: 1.41, Ks_mm_per_h: 4.5   },
      "Sandy Clay Loam": { theta_r: 0.100, theta_s: 0.39, alpha: 5.9, n: 1.48, Ks_mm_per_h: 13.1 },
      "Clay Loam":     { theta_r: 0.095, theta_s: 0.41, alpha: 1.9,  n: 1.31, Ks_mm_per_h: 2.6   },
      "Silty Clay Loam":{ theta_r: 0.089, theta_s: 0.43, alpha: 1.0, n: 1.23, Ks_mm_per_h: 0.7   },
      "Sandy Clay":    { theta_r: 0.100, theta_s: 0.38, alpha: 2.7,  n: 1.23, Ks_mm_per_h: 1.2   },
      "Silty Clay":    { theta_r: 0.070, theta_s: 0.36, alpha: 0.5,  n: 1.09, Ks_mm_per_h: 0.2   },
      "Clay":          { theta_r: 0.068, theta_s: 0.38, alpha: 0.8,  n: 1.09, Ks_mm_per_h: 0.6   }
    };

    // Custom Turbo-like colorscale for peak-flow reduction
    const TURBO_SCALE = [
      [0.00, '#30123b'],
      [0.15, '#4145ab'],
      [0.30, '#2c9df2'],
      [0.45, '#20c96b'],
      [0.60, '#8fd744'],
      [0.75, '#f6e620'],
      [0.90, '#fdae21'],
      [1.00, '#f1605d']
    ];

    const METRIC_INFO = {
      eta_p_pct: {
        label: 'Peak flow reduction [%]',
        shortTitle: 'Peak flow reduction',
        colorscale: TURBO_SCALE,
        toColorValue: v => v
      },
      DetTime_min: {
        label: 'Detention time [h]',
        shortTitle: 'Detention time',
        colorscale: 'Viridis',
        toColorValue: v => v / 60.0 // min -> h
      },
      Delta_tp_min: {
        label: 'Time-to-peak delay [h]',
        shortTitle: 'Time-to-peak delay',
        colorscale: 'Cividis',
        toColorValue: v => v / 60.0 // min -> h
      }
    };

    // ========= GLOBAL STATE =================================================
    let dbMetrics = [];
    let QinHydro = null;   // [nSteps][nKeep]
    let QoutHydro = null;  // [nSteps][nKeep]
    let tMinutesHydro = null;
    let metricsByIdx = new Map();
    let currentSubset = [];
    let currentSoil = null;
    let currentPeff = null;
    let currentHydroScenario = null;
    let currentHydroData = null;

    // ========= HELPERS ======================================================

    function mmToInch(mm) {
      return mm / 25.4;
    }

    function formatPeffLabel(mmVal) {
      const inch = mmToInch(mmVal);
      return `${mmVal.toFixed(1)} mm (${inch.toFixed(2)} in)`;
    }

    function setStatus(msg, isError = false) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = 'status' + (isError ? ' error' : '');
    }

    function updateSoilParamsLine(soilName) {
      const el = document.getElementById('soil-params');
      const p = SOIL_PROPS[soilName];

      if (!p) {
        el.textContent = soilName;
        return;
      }

      const dtheta = p.theta_s - p.theta_r;
      const Ks_mps = p.Ks_mm_per_h / 1000 / 3600; // mm/h -> m/s

      const tex =
        `${soilName} \\(\\; -\\; \\alpha = ${p.alpha.toFixed(2)}\\,\\mathrm{m}^{-1},` +
        `\\; n = ${p.n.toFixed(2)},` +
        `\\; \\Delta\\theta = ${dtheta.toFixed(3)},` +
        `\\; K_s = ${Ks_mps.toExponential(2)}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}\\)`;

      el.innerHTML = tex;
      if (window.MathJax && window.MathJax.typesetPromise) {
        MathJax.typesetPromise([el]).catch(() => {});
      }
    }

    function uniqueSortedNumeric(arr) {
      return Array.from(new Set(arr)).sort((a, b) => a - b);
    }

    // ========= HYDROGRAPH HANDLING =========================================

    function getHydroDataFromScenario(m) {
      if (!m || m.hydroIndex === undefined || m.hydroIndex < 0) return null;
      if (!QinHydro || !QoutHydro || !tMinutesHydro) return null;

      const col = m.hydroIndex; // 0-based column in QinHydro/QoutHydro
      const area = m.ATC_m2;
      if (!area || area <= 0) return null;

      const tHours = tMinutesHydro.map(v => v / 60.0);

      const inflow = QinHydro.map(row => {
        const q = row[col] || 0;
        return q / area * 1000 * 3600; // m3/s -> mm/h
      });

      const outflow = QoutHydro.map(row => {
        const q = row[col] || 0;
        return q / area * 1000 * 3600;
      });

      return { tHours, inflow, outflow };
    }

    function renderHydrographForScenario(m) {
      const div = document.getElementById('hydro-plot');
      const btn = document.getElementById('btn-download');

      if (!m) {
        currentHydroScenario = null;
        currentHydroData = null;
        btn.disabled = true;

        const emptyData = [{
          x: [0],
          y: [0],
          mode: 'lines',
          line: {color: '#cccccc'},
          hoverinfo: 'skip',
          showlegend: false
        }];

        const layout = {
          title: 'Hydrographs — no scenario selected',
          margin: {l: 60, r: 10, t: 40, b: 45},
          xaxis: {
            title: 'Time [h]',
            zeroline: false,
            showgrid: false,
            ticks: 'outside',
            tickwidth: 2,
            linewidth: 2,
            linecolor: '#000000'
          },
          yaxis: {
            title: 'Flux [mm/h]',
            zeroline: false,
            showgrid: false,
            ticks: 'outside',
            tickwidth: 2,
            linewidth: 2,
            linecolor: '#000000'
          },
          showlegend: false
        };
        Plotly.react(div, emptyData, layout, {responsive: true});
        document.getElementById('hydro-title').textContent =
          'Hydrographs — no stored hydrograph data for this scenario';
        return;
      }

      const hData = getHydroDataFromScenario(m);
      if (!hData) {
        currentHydroScenario = m;
        currentHydroData = null;
        btn.disabled = true;

        const emptyData = [{
          x: [0],
          y: [0],
          mode: 'lines',
          line: {color: '#cccccc'},
          hoverinfo: 'skip',
          showlegend: false
        }];

        const layout = {
          title: 'Hydrographs — no stored hydrograph data for this scenario',
          margin: {l: 60, r: 10, t: 40, b: 45},
          xaxis: {
            title: 'Time [h]',
            zeroline: false,
            showgrid: false,
            ticks: 'outside',
            tickwidth: 2,
            linewidth: 2,
            linecolor: '#000000'
          },
          yaxis: {
            title: 'Flux [mm/h]',
            zeroline: false,
            showgrid: false,
            ticks: 'outside',
            tickwidth: 2,
            linewidth: 2,
            linecolor: '#000000'
          },
          showlegend: false
        };
        Plotly.react(div, emptyData, layout, {responsive: true});
        document.getElementById('hydro-title').textContent =
          'Hydrographs — no stored hydrograph data for this scenario';
        return;
      }

      currentHydroScenario = m;
      currentHydroData = hData;
      btn.disabled = false;

      const traceIn = {
        x: hData.tHours,
        y: hData.inflow,
        mode: 'lines',
        name: 'Inflow',
        line: {color: '#BC262D', width: 2.5, dash: 'dash'}
      };

      const traceOut = {
        x: hData.tHours,
        y: hData.outflow,
        mode: 'lines',
        name: 'Outflow',
        line: {color: '#0000A3', width: 2.5}
      };

      const layout = {
        title: `Hydrographs — ${m.soilName}, area-ratio = ${(m.area_ratio * 100).toFixed(1)}%, LID depth = ${m.Ld_m.toFixed(2)} m, tp = ${m.tp_min.toFixed(1)} min`,
        margin: {l: 60, r: 10, t: 50, b: 45},
        xaxis: {
          title: 'Time [h]',
          zeroline: false,
          showgrid: false,
          ticks: 'outside',
          tickwidth: 2,
          linewidth: 2,
          linecolor: '#000000'
        },
        yaxis: {
          title: 'Flux [mm/h]',
          zeroline: false,
          showgrid: false,
          ticks: 'outside',
          tickwidth: 2,
          linewidth: 2,
          linecolor: '#000000'
        },
        legend: {
          x: 0.02,
          y: 0.98,
          bgcolor: 'rgba(255,255,255,0.8)'
        }
      };

      Plotly.react(div, [traceIn, traceOut], layout, {responsive: true});
      document.getElementById('hydro-title').textContent =
        'Hydrographs — inflow and outflow (mm/h)';
    }

    function downloadCurrentHydroCSV() {
      if (!currentHydroScenario || !currentHydroData) return;

      const m = currentHydroScenario;
      const h = currentHydroData;
      const header = 'time_h,inflow_mmph,outflow_mmph\n';
      let rows = '';
      for (let i = 0; i < h.tHours.length; i++) {
        rows += `${h.tHours[i]},${h.inflow[i]},${h.outflow[i]}\n`;
      }
      const csv = header + rows;

      const blob = new Blob([csv], {type: 'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const soilSlug = m.soilName.replace(/\s+/g, '_');
      a.href = url;
      a.download = `hydrograph_${soilSlug}_AR${(m.area_ratio*100).toFixed(1)}_Ld${m.Ld_m.toFixed(2)}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ========= DESIGN PLOTS =================================================

    function buildDesignPlot(metricName, divId, subset, peffVal) {
      const info = METRIC_INFO[metricName];
      const div = document.getElementById(divId);

      const x = [];
      const y = [];
      const z = [];
      const c = [];
      const custom = [];

      const xUn = [];
      const yUn = [];
      const zUn = [];
      const customUn = [];

      subset.forEach(m => {
        const xVal = m.area_ratio * 100.0; // percentage
        const yVal = m.Ld_m;
        const zVal = m.tp_min;
        const raw = m[metricName];

        if (raw === null || raw === undefined || isNaN(raw)) {
          xUn.push(xVal);
          yUn.push(yVal);
          zUn.push(zVal);
          customUn.push(m.idx);
        } else {
          x.push(xVal);
          y.push(yVal);
          z.push(zVal);
          c.push(info.toColorValue(raw));
          custom.push(m.idx);
        }
      });

      const cmin = c.length ? Math.min(...c) : 0;
      const cmax = c.length ? Math.max(...c) : 1;
      const peffLabel = formatPeffLabel(peffVal);

      const traceFeasible = {
        x, y, z,
        mode: 'markers',
        type: 'scatter3d',
        name: 'Feasible',
        customdata: custom,
        marker: {
          size: 5,
          color: c,
          colorscale: info.colorscale,
          cmin,
          cmax,
          showscale: true,
          colorbar: {
            title: {
              text: info.label,
              side: 'right'
            },
            thickness: 12,
            len: 0.9,
            outlinewidth: 2,
            ticks: 'inside'
          },
          line: {
            width: 1.5,
            color: 'rgba(0,0,0,0.7)'
          }
        },
        hovertemplate:
          'Area-ratio: %{x:.1f}%<br>' +
          'LID depth: %{y:.2f} m<br>' +
          't_p: %{z:.1f} min<br>' +
          `${info.label}: %{marker.color:.2f}<extra></extra>`
      };

      const traceUnfeasible = {
        x: xUn,
        y: yUn,
        z: zUn,
        mode: 'markers',
        type: 'scatter3d',
        name: 'Unfeasible / failed',
        customdata: customUn,
        marker: {
          size: 4,
          color: 'rgba(220,220,220,0.1)',
          showscale: false,
          line: {
            width: 1.3,
            color: 'rgba(80,80,80,0.7)'
          }
        },
        hovertemplate:
          'Area-ratio: %{x:.1f}%<br>' +
          'LID depth: %{y:.2f} m<br>' +
          't_p: %{z:.1f} min<br>' +
          '<b>Unfeasible / failed</b><extra></extra>'
      };

      // Compute global min/max to set full ranges (include feasible + unfeasible)
      const allX = x.concat(xUn);
      const allY = y.concat(yUn);
      const allZ = z.concat(zUn);
      
      let xRange = null, yRange = null, zRange = null;
      if (allX.length > 0) {
        const xMin = Math.min(...allX);
        const xMax = Math.max(...allX);
        const dx = (xMax - xMin) * 0.05 || 1;
        xRange = [xMin - dx, xMax + dx];
      }
      if (allY.length > 0) {
        const yMin = Math.min(...allY);
        const yMax = Math.max(...allY);
        const dy = (yMax - yMin) * 0.05 || 0.1;
        yRange = [yMin - dy, yMax + dy];
      }
      if (allZ.length > 0) {
        const zMin = Math.min(...allZ);
        const zMax = Math.max(...allZ);
        const dz = (zMax - zMin) * 0.05 || 1;
        zRange = [zMin - dz, zMax + dz];
      }

      const layout = {
        title: `${info.shortTitle} — ${currentSoil}, P_eff = ${peffLabel}`,
        margin: {l: 0, r: 0, t: 40, b: 0},
        scene: {
          xaxis: {
            title: 'Area-ratio [%]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            range: xRange || undefined
          },
          yaxis: {
            title: 'LID depth [m]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            range: yRange || undefined
          },
          zaxis: {
            title: 'Inflow time to peak [min]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            range: zRange || undefined
          },
          aspectmode: 'cube',
          camera: {
            eye: {x: 1.7, y: 1.7, z: 1.5}
          }
        },
        showlegend: false
      };


      const data = [];
      if (x.length) data.push(traceFeasible);
      if (xUn.length) data.push(traceUnfeasible);

      Plotly.react(div, data, layout, {responsive: true});

      // Attach click handler so that clicking on a point updates the hydrograph
      if (div && typeof div.on === 'function') {
        div.on('plotly_click', ev => {
          if (!ev.points || !ev.points.length) return;
          const idx = ev.points[0].customdata;
          if (idx === undefined || idx === null) return;
          const scenario = metricsByIdx.get(idx);
          if (!scenario) return;
          renderHydrographForScenario(scenario);
        });
      }
    }


    function updatePlotsAndHydro() {
      if (!dbMetrics.length || currentSoil === null || currentPeff === null) return;

      currentSubset = dbMetrics.filter(m =>
        m.soilName === currentSoil &&
        m.Peff_catch_mm === currentPeff
      );

      buildDesignPlot('eta_p_pct', 'plot-eta', currentSubset, currentPeff);
      buildDesignPlot('DetTime_min', 'plot-det', currentSubset, currentPeff);
      buildDesignPlot('Delta_tp_min', 'plot-dtp', currentSubset, currentPeff);

      // Pick default scenario with hydroIndex >= 0 for current view
      let candidate = null;
      if (currentHydroScenario &&
          currentHydroScenario.soilName === currentSoil &&
          currentHydroScenario.Peff_catch_mm === currentPeff &&
          currentHydroScenario.hydroIndex !== undefined &&
          currentHydroScenario.hydroIndex >= 0) {
        candidate = currentHydroScenario;
      } else {
        candidate = currentSubset.find(
          m => m.hydroIndex !== undefined && m.hydroIndex >= 0
        ) || null;
      }
      renderHydrographForScenario(candidate);
    }

    // ========= UI INIT ======================================================

    function initUI() {
      const soilSel = document.getElementById('soil-select');
      const peffSel = document.getElementById('peff-select');
      const btnDownload = document.getElementById('btn-download');

      // Soils: start with sandy → clayey ordering
      const soilNames = Array.from(new Set(dbMetrics.map(m => m.soilName)));
      const sortedSoils = soilNames.slice().sort((a, b) => a.localeCompare(b));
      const sandyFirst = sortedSoils.sort((a, b) => {
        const sandyA = /sand/i.test(a);
        const sandyB = /sand/i.test(b);
        if (sandyA && !sandyB) return -1;
        if (!sandyA && sandyB) return 1;
        return a.localeCompare(b);
      });

      soilSel.innerHTML = '';
      sandyFirst.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        soilSel.appendChild(opt);
      });

      currentSoil = sandyFirst[0] || null;
      soilSel.value = currentSoil;

      // Peff options for current soil
      function refreshPeffOptions() {
        const filtered = dbMetrics.filter(m => m.soilName === currentSoil);
        const peffs = uniqueSortedNumeric(filtered.map(m => m.Peff_catch_mm));
      
        peffSel.innerHTML = '';
        peffs.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v;
          opt.textContent = formatPeffLabel(v);
          peffSel.appendChild(opt);
        });
      
        // --- choose default Peff closest to 25.4 mm (≈ 1 inch) ---
        const targetMm = 25.4;
        if (peffs.length > 0) {
          let best = peffs[0];
          let bestDiff = Math.abs(peffs[0] - targetMm);
          for (let i = 1; i < peffs.length; i++) {
            const diff = Math.abs(peffs[i] - targetMm);
            if (diff < bestDiff) {
              bestDiff = diff;
              best = peffs[i];
            }
          }
          currentPeff = best;
          peffSel.value = best;
        } else {
          currentPeff = null;
        }
      }


      refreshPeffOptions();
      soilSel.disabled = false;
      peffSel.disabled = false;

      updateSoilParamsLine(currentSoil);
      updatePlotsAndHydro();

      soilSel.addEventListener('change', () => {
        currentSoil = soilSel.value;
        updateSoilParamsLine(currentSoil);
        const filtered = dbMetrics.filter(m => m.soilName === currentSoil);
        const peffs = uniqueSortedNumeric(filtered.map(m => m.Peff_catch_mm));
        peffSel.innerHTML = '';
        peffs.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v;
          opt.textContent = formatPeffLabel(v);
          peffSel.appendChild(opt);
        });
        currentPeff = peffs[0] || null;
        if (currentPeff !== null) peffSel.value = currentPeff;
        updatePlotsAndHydro();
      });

      peffSel.addEventListener('change', () => {
        currentPeff = parseFloat(peffSel.value);
        updatePlotsAndHydro();
      });

      btnDownload.addEventListener('click', downloadCurrentHydroCSV);

    }

    // ========= DATA LOADING =================================================

    async function loadData() {
      try {
        setStatus('Loading data…');
        const resp = await fetch(DATA_URL, {cache: 'no-cache'});
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status} while fetching ${DATA_URL}`);
        }
        const raw = await resp.json();

        dbMetrics = raw.metrics || [];
        if (!Array.isArray(dbMetrics) || !dbMetrics.length) {
          throw new Error('No "metrics" array in JSON.');
        }

        QinHydro = raw.Qin_all || null;
        QoutHydro = raw.Qout_all || null;
        tMinutesHydro = raw.t_minutes || null;

        // Build idx map
        metricsByIdx.clear();
        dbMetrics.forEach(m => {
          if (m.idx === undefined) return;
          metricsByIdx.set(m.idx, m);
        });

        setStatus('Data loaded. Use the controls to explore the design space.');
        initUI();
      } catch (err) {
        console.error(err);
        setStatus(`Error loading data: ${err.message}`, true);
      }
    }

    // ========= BOOTSTRAP ====================================================

    document.addEventListener('DOMContentLoaded', () => {
      // Logo insertion
      if (LOGO_URL) {
        const box = document.getElementById('logo-box');
        const img = document.createElement('img');
        img.src = LOGO_URL;
        img.alt = 'DRAIN-LID logo';
        box.appendChild(img);
      }

      loadData();
    });
  </script>
</body>
</html>

    
