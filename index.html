<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DRAIN-LID Design Performance Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <!-- MathJax JUST for the soil-parameter line -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  <style>
    :root {
      --bg: #ffffff;
      --fg: #222222;
      --accent: #1f77b4;
      --muted: #777777;
      --border: #dddddd;
      --panel-bg: #f8f8f8;
      --font-main: "Palatino Linotype", "Book Antiqua", Palatino, "Times New Roman", serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 1.5rem;
      font-family: var(--font-main);
      background: var(--bg);
      color: var(--fg);
    }

    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }

    h1 {
      font-size: 1.6rem;
      margin: 0;
    }

    .subtitle {
      margin: 0.15rem 0 0 0;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .logo-box img {
      max-height: 64px;
      width: auto;
      display: block;
    }

    .soil-params-wrapper {
      margin: 0.25rem 0 0.75rem 0;
      padding: 0.4rem 0.75rem;
      border-radius: 0.5rem;
      background: #fbfbfb;
      border: 1px solid #eeeeee;
      font-size: 0.95rem;
    }

    .concept-figure {
      margin: 1rem 0 1.25rem 0;
      text-align: center;
    }

    .concept-figure img {
      max-width: 100%;
      height: auto;
    }

    .concept-figure .caption {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 0.35rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 0.9rem;
      margin-bottom: 1rem;
      background: var(--panel-bg);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      min-width: 200px;
    }

    .control-group label {
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
      color: var(--muted);
    }

    select {
      padding: 0.35rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      font-size: 0.9rem;
      background: #fff;
      cursor: pointer;
    }

    select:disabled {
      background: #f0f0f0;
      cursor: not-allowed;
      color: #aaaaaa;
    }

    .plots-row {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    .plot-panel {
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.25rem;
      background: #ffffff;
    }

    .plot-div {
      width: 100%;
      height: 360px;
    }

    .hydro-panel {
      margin-top: 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.5rem 0.75rem 0.75rem 0.75rem;
      background: #ffffff;
    }

    #hydro-plot {
      width: 100%;
      height: 260px;
    }

    .hydro-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.25rem;
    }

    .status {
      margin-top: 0.35rem;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .status.error {
      color: #b00020;
    }

    .legend-note {
      margin-top: 0.4rem;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .about-box {
      margin-top: 1.0rem;
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.4;
    }

    .about-box strong {
      color: #444;
    }

    button {
      padding: 0.3rem 0.7rem;
      font-size: 0.8rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: #f4f4f4;
      cursor: pointer;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }

    input[type="number"] {
      padding: 0.35rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      font-size: 0.9rem;
      width: 100%;
    }

    input[type="number"]:disabled {
      background: #f0f0f0;
      cursor: not-allowed;
      color: #aaaaaa;
    }

    .cost-panel {
      margin-top: 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.5rem 0.75rem 0.75rem 0.75rem;
      background: #ffffff;
    }

    #cost-plot {
      width: 100%;
      height: 260px;
    }

    .method-panel {
      background: var(--panel-bg, #f8f8f8);
      border: 1px solid var(--border, #dddddd);
      border-radius: 8px;
      padding: 1.5rem 1.75rem;
      margin-bottom: 1.5rem;
    }

    .method-panel h2 {
      margin-top: 0;
      margin-bottom: 0.75rem;
      font-size: 1.3rem;
    }

    .method-panel h3 {
      margin-top: 1.1rem;
      margin-bottom: 0.35rem;
      font-size: 1.05rem;
    }

    .method-panel p {
      margin: 0.3rem 0;
      line-height: 1.4;
    }

    .method-panel ul {
      margin: 0.4rem 0 0.8rem 1.25rem;
      padding: 0;
    }

    .method-panel .math {
      margin: 0.4rem 0 0.7rem;
    }
  </style>
</head>
<body>
  <div class="page-header">
    <div>
      <h1>DRAIN-LID Design Performance Explorer</h1>
      <p class="subtitle">
        Interactive design-space visualization from the DRAIN-LID database.
        For detailed parameter and model descriptions, please scroll to the bottom of this page.
        <strong>If you are using a mobile phone, use it horizontally.</strong>
      </p>
    </div>
    <div class="logo-box" id="logo-box">
      <!-- Logo gets injected here if LOGO_URL is set in JS -->
    </div>
  </div>

  <div class="soil-params-wrapper">
    <span id="soil-params">
      <!-- Filled by JS, rendered with MathJax -->
    </span>
  </div>

  <!-- Conceptual layout figure -->
  <div class="concept-figure">
    <img src="Problem_Layout.png"
         alt="Conceptual cross-section of the bioretention cell showing inflow, infiltration, percolation, soil storage, and underdrain outflow.">
    <div class="caption">
      Conceptual layout of the bioretention cell and main modeled fluxes.
    </div>
  </div>

  <div class="controls">
    <div class="control-group">
      <label for="soil-select">Soil type</label>
      <select id="soil-select" disabled></select>
    </div>

    <div class="control-group">
      <label for="peff-select">Effective precipitation, Pef</label>
      <select id="peff-select" disabled></select>
    </div>

    <div class="control-group">
      <label for="tp-min-input">Min inflow time to peak t<sub>p</sub> [min]</label>
      <input type="number" id="tp-min-input" step="1" />
    </div>

    <div class="control-group">
      <label for="tp-max-input">Max inflow time to peak t<sub>p</sub> [min]</label>
      <input type="number" id="tp-max-input" step="1" />
    </div>

    <div class="control-group">
      <label for="min-eta-input">Min peak flow reduction [%]</label>
      <input type="number" id="min-eta-input" value="60" step="5" />
    </div>

    <div class="control-group">
      <label for="min-det-h-input">Min detention time [h]</label>
      <input type="number" id="min-det-h-input" value="4" step="0.5" />
    </div>

    <div class="control-group">
      <label for="min-delay-h-input">Min time-to-peak delay [h]</label>
      <input type="number" id="min-delay-h-input" value="0" step="0.25" />
    </div>

    <div class="control-group">
      <label for="max-pond-m-input">Max ponding depth [m]</label>
      <input type="number" id="max-pond-m-input" value="0.30" step="0.05" />
    </div>

    <div class="control-group">
      <label for="c-vol-input">c<sub>vol</sub> — excavation + media [\$/m³]</label>
      <input type="number" id="c-vol-input" value="210" step="10" />
    </div>

    <div class="control-group">
      <label for="c-surf-input">c<sub>surf</sub> — surface works [\$/m²]</label>
      <input type="number" id="c-surf-input" value="55" step="5" />
    </div>

    <div class="control-group">
      <label for="c-om-input">c<sub>O&amp;M</sub> — annual O&amp;M [\$/m²/yr]</label>
      <input type="number" id="c-om-input" value="6" step="1" />
    </div>

    <div class="control-group">
      <label for="design-life-input">Design life T [years]</label>
      <input type="number" id="design-life-input" value="30" step="1" />
    </div>

    <div class="control-group">
      <label for="discount-rate-input">Discount rate i [-]</label>
      <input type="number" id="discount-rate-input" value="0.03" step="0.005" />
    </div>
  </div>

  <div class="plots-row">
    <div class="plot-panel">
      <div id="plot-eta" class="plot-div"></div>
      <button id="btn-download-eta" disabled>Download CSV</button>
    </div>
    <div class="plot-panel">
      <div id="plot-det" class="plot-div"></div>
      <button id="btn-download-det" disabled>Download CSV</button>
    </div>
    <div class="plot-panel">
      <div id="plot-dtp" class="plot-div"></div>
      <button id="btn-download-dtp" disabled>Download CSV</button>
    </div>
    <div class="plot-panel">
      <div id="plot-pond" class="plot-div"></div>
      <button id="btn-download-pond" disabled>Download CSV</button>
    </div>
  </div>

  <div class="hydro-panel">
    <div class="hydro-header">
      <div id="hydro-title">Hydrographs — no scenario selected yet</div>
      <button id="btn-download" disabled>Download CSV</button>
    </div>
    <div id="hydro-plot"></div>
    <div id="status" class="status">Loading data…</div>
    <div class="legend-note">
      Markers with outline only correspond to designs for which the solver
      failed or violated ponding constraints. Hydrographs are shown in
      normalized flux units (mm/h) over the LID surface. Due to size
      limitations, only solutions with peak flow reductions of 20–50% are
      stored for the first 24&nbsp;h, although the model is run for 48&nbsp;h.
    </div>
  </div>

  <div class="cost-panel">
    <div class="hydro-header">
      <div id="cost-title">Lifecycle cost — no feasible set yet</div>
      <button id="btn-download-cost" disabled>Download CSV</button>
    </div>
    <div id="cost-plot"></div>
    <div id="cost-status" class="status">
      Set hydrologic filters and select a soil and Pef to see cost–performance results.
    </div>
  </div>

  <div class="about-box">
    <p>
      <strong>About this explorer.</strong>
      This interactive tool was developed by Marcus N. Gomes Jr., PhD. To
      visualize the design space of infiltration-based Low Impact Development
      systems simulated with the DRAIN-LID model. Each point represents a
      numerical solution of a mixed-form Richards equation coupled to a
      structural drainage module under a specified inflow hydrograph and media
      configuration. The area-ratio axis shows the ratio between the LID
      surface and the contributing catchment area.
    </p>
  </div>

  <section id="methods-background" class="method-panel">
    <h2>How the Model Works</h2>
    <p>
      The <strong>DRAIN-LID_Designer</strong> toolbox is built on a physics-based numerical
      model that represents vertical water movement through the bioretention media,
      the inflow hydrograph from the contributing catchment, and the lifecycle
      costs of alternative designs. This section gives a compact overview of the
      underlying equations and performance metrics so users can interpret the
      database and cost-performance plots.
    </p>

    <h3>Richards-based Vertical Flow Model</h3>
    <p>
      Vertical flow through the engineered media is described by the
      one-dimensional mixed-form Richards equation, with pressure head
      \(h(z,t)\) as the primary state variable:
    </p>
    <div class="math">
      \[
        \frac{\partial \theta(h)}{\partial t}
        + S_s \frac{\partial h}{\partial t}
        =
        \frac{\partial}{\partial z}
        \left[
          K(h)\left(\frac{\partial h}{\partial z} + 1\right)
        \right]
        + S(z,t).
      \]
    </div>
    <p>
      Here \(z\) is depth, \(\theta(h)\) is volumetric water content,
      \(K(h)\) is hydraulic conductivity, \(S_s\) is specific storage,
      and \(S(z,t)\) represents sources and sinks associated with drainage
      and lateral exchange. The soil hydraulic properties are obtained
      from the van Genuchten–Mualem constitutive relationships:
    </p>
    <div class="math">
      \[
        \theta(h) =
        \begin{cases}
          \theta_r + (\theta_s - \theta_r)
          \left[1 + (\alpha |h|)^n\right]^{-m}, & h &lt; 0,\\[4pt]
          \theta_s, & h \ge 0,
        \end{cases}
      \]
      \[
        K(h) =
        \begin{cases}
          K_s
          \left[1 + (\alpha |h|)^n\right]^{-m l}
          \left\{
            1 - (\alpha |h|)^{n-1}
            \left[1 + (\alpha |h|)^n\right]^{-m}
          \right\}^2, & h &lt; 0,\\[4pt]
          K_s, & h \ge 0,
        \end{cases}
      \]
    </div>
    <p>
      with \(\theta_r\), \(\theta_s\), \(\alpha\), \(n\), and \(K_s\)
      taken from representative USDA soil textural classes (Hydrus soil
      catalog). The model is solved with an implicit finite-volume scheme
      and a Newton–Raphson iteration with adaptive time stepping, so that
      each design configuration in the database corresponds to a full
      Richards-equation simulation.
    </p>

    <h3>Design Hydrograph and Catchment Inputs</h3>
    <p>
      The inflow to the bioretention cell is represented by a synthetic
      design hydrograph that depends on three catchment-scale descriptors:
    </p>
    <ul>
      <li>Effective rainfall depth \(P_{\mathrm{eff}}\) (runoff-producing depth)</li>
      <li>Upstream contributing area \(A_{\mathrm{up}}\)</li>
      <li>Time to peak \(t_{\mathrm{p}}\) of the runoff hydrograph</li>
    </ul>
    <p>
      A Nash unit-hydrograph formulation is used:
    </p>
    <div class="math">
      \[
        Q_{\mathrm{in}}(t) =
        Q_{\mathrm{p}}
        \left(
          \frac{t}{t_{\mathrm{p}}}
          \exp\left[1 - \frac{t}{t_{\mathrm{p}}}\right]
        \right)^{m-1},
      \]
    </div>
    <p>
      where \(m\) is a shape parameter and \(Q_{\mathrm{p}}\) is chosen so
      that the total runoff volume equals
      \(V_{\mathrm{r}} = P_{\mathrm{eff}} \, A_{\mathrm{up}}\).
      For each combination of \((P_{\mathrm{eff}}, A_{\mathrm{up}}, t_{\mathrm{p}})\),
      bioretention surface area \(A\) (via area ratio \(r = A / A_{\mathrm{up}}\)),
      media depth \(L_d\), and soil type, the model routes the design hydrograph
      through the bioretention profile.
    </p>

    <h3>Hydrologic Performance Metrics</h3>
    <p>
      The database stores several hydrologic performance metrics for
      each realization, allowing users to screen designs without rerunning
      the numerical model. The main quantities used in the interface are:
    </p>

    <h4>Peak Flow Reduction</h4>
    <p>
      Peak attenuation is defined as the percentage reduction in peak discharge
      between inflow and outflow:
    </p>
    <div class="math">
      \[
        \eta_{\mathrm{p}} =
        100 \,
        \frac{Q_{\mathrm{p}}^{\,i} - Q_{\mathrm{p}}^{\,o}}
             {Q_{\mathrm{p}}^{\,i}},
      \]
    </div>
    <p>
      where \(Q_{\mathrm{p}}^{\,i}\) and \(Q_{\mathrm{p}}^{\,o}\) are the inflow
      and outflow peaks, respectively. Larger values of \(\eta_{\mathrm{p}}\)
      indicate stronger flood-peak mitigation.
    </p>

    <h4>Time-to-Peak Delay</h4>
    <p>
      The shift in the hydrograph peak due to storage and infiltration is
      measured as
    </p>
    <div class="math">
      \[
        \Delta t_{\mathrm{p}} = t_{\mathrm{p}}^{\,o} - t_{\mathrm{p}}^{\,i},
      \]
    </div>
    <p>
      where \(t_{\mathrm{p}}^{\,i}\) and \(t_{\mathrm{p}}^{\,o}\) are the
      times of the inflow and outflow peaks. Positive values indicate a
      delayed outflow peak, which can help desynchronize flows in
      downstream networks.
    </p>

    <h4>Detention Time</h4>
    <p>
      Detention time characterizes the drawdown period over which the
      bioretention system continues to release flow after the inflow peak:
    </p>
    <div class="math">
      \[
        \Delta t_{\mathrm{d}} =
          t\bigl(Q_{\mathrm{out}}(t) \le \tau\bigr) - t_{\mathrm{p}}^{\,i},
      \]
    </div>
    <p>
      where \(\tau\) is a small threshold discharge. In the simulations,
      \(\tau\) is set to a fraction of the inflow peak
      (e.g., \(0.25\%\times Q_{\mathrm{p}}^{\,i}\)), so that
      \(\Delta t_{\mathrm{d}}\) represents the time needed for outflow
      to decay to nearly negligible levels.
    </p>

    <h3>Lifecycle Cost Model</h3>
    <p>
      The hydrologic analysis by associating each
      hydrologically feasible design is coupled with a simplified lifecycle cost.
      The toolbox distinguishes between construction (capital expenditure)
      and recurring operation and maintenance (O&amp;M):
    </p>

    <h4>Construction Cost (CapEx)</h4>
    <p>
      Construction cost is parameterized as a combination of
      volume-based and area-based components:
    </p>
    <div class="math">
      \[
        C_{\mathrm{CapEx}} =
          c_{\mathrm{vol}} \, A \, L_{\mathrm d}
          + c_{\mathrm{surf}} \, A,
      \]
    </div>
    <p>
      where:
    </p>
    <ul>
      <li>\(A\): bioretention surface area,</li>
      <li>\(L_{\mathrm d}\): media depth,</li>
      <li>\(c_{\mathrm{vol}}\): unit cost of excavation and media installation [\$/m\(^3\)],</li>
      <li>\(c_{\mathrm{surf}}\): unit cost of surface preparation and planting [\$/m\(^2\)].</li>
    </ul>
    <p>
      These coefficients are exposed as user-editable parameters in the
      toolbox, so they can be calibrated to local bid prices or cost
      worksheets.
    </p>

    <h4>Operation and Maintenance (O&amp;M)</h4>
    <p>
      Annual O&amp;M costs are assumed proportional to the footprint area:
    </p>
    <div class="math">
      \[
        C_{\mathrm{O\&M,annual}} = c_{\mathrm{O\&M}} \, A,
      \]
    </div>
    <p>
      where \(c_{\mathrm{O\&M}}\) is a per-area annual maintenance cost
      [\$/m\(^2\)/year]. To express O&amp;M in present-value terms over a
      design life \(T\) with discount rate \(i\), a standard annuity factor
      is used:
    </p>
    <div class="math">
      \[
        F(i,T) =
        \frac{1 - (1 + i)^{-T}}{i}.
      \]
    </div>

    <h4>Net Present Value (NPV)</h4>
    <p>
      The total lifecycle cost for a design is then
    </p>
    <div class="math">
      \[
        C_{\mathrm{NPV}} =
          C_{\mathrm{CapEx}}
          + F(i,T) \, c_{\mathrm{O\&M}} \, A.
      \]
    </div>
    <p>
In the interface, these cost calculations are applied only to the
subset of simulations that satisfy minimum hydrologic performance
criteria (e.g., a given peak reduction and detention time), enabling
users to compare how different soil types, area ratios, and media
depths trade off between cost and hydrologic benefit.
</p>
 
  </section>

    <h3>Modeling Assumptions</h3>
    <p>
      The simulations underlying the DRAIN-LID design database rely on a set of 
      simplifying but physically motivated assumptions intended to capture 
      first-order hydrologic behavior while maintaining computational tractability 
      for the full design space of soil types, rainfall inputs, and geometries. 
      The principal assumptions are:
    </p>
    
    <ul>
      <li>
        <strong>Initial soil conditions.</strong> 
        All simulations begin from a hydrostatic pressure profile with the water 
        table located well below the bioretention profile, producing an initially 
        unsaturated soil column with 50% of effective saturation. No antecedent rainfall or pre-event surface water
        is imposed.
      </li>
    
      <li>
        <strong>Lined system.</strong> 
        The bioretention cell is modeled as laterally lined, eliminating 
        exfiltration to the native subgrade. All outflow occurs through the 
        underdrain/bottom seepage or surface overflow.
      </li>
    
      <li>
        <strong>Underdrain boundary condition.</strong>
        The underdrain invert is treated as a free-drain (unit gradient) boundary,
        justified because underdrain hydraulic capacity is assumed to far exceed 
        the seepage-rate capacity of the media. As a result, the underdrain does 
        not behave as a throttling control.
      </li>
    
      <li>
        <strong>Spatial discretization.</strong> 
        The vertical soil column is discretized using ~20 finite-volume nodes, 
        distributed non-uniformly with refinement near the soil surface and near 
        the underdrain. The distribution follows the node-spacing strategy used in 
        <em>Hydrus-1D</em> to improve stability during sharp wetting‐front movement.
      </li>
    
      <li>
        <strong>Homogeneous soil properties.</strong> 
        Hydraulic parameters are spatially invariant; no layering or vertical 
        heterogeneity is represented. Media are assumed to behave as homogeneous 
        USDA textural classes following van Genuchten–Mualem relations. Engineered 
        media mixes may therefore differ from the parameter sets used here.
      </li>
    
      <li>
        <strong>No evapotranspiration.</strong> 
        Evapotranspiration is omitted because storm durations (≤ 48 h) are short relative to 
        atmospheric‐demand timescales, and because the surface is assumed fully 
        wetted during the event, suppressing root water uptake.
      </li>
    
      <li>
        <strong>1D approximation.</strong>  
        Flow is vertical (1-D), neglecting lateral divergence and sidewall 
        interactions. This is consistent with lined systems and large plan-form 
        aspect ratios.
      </li>
    
      <li>
        <strong>Representative USDA soils.</strong>  
        Simulations use Carsel–Parrish (1988) USDA hydraulic parameter sets.  
        Fully engineered bioretention media may exhibit higher conductivity, 
        altered retention curves, or different pore-size distributions, which 
        could shift results outside this parameter envelope.
      </li>
    </ul>
    
    <p>
      These assumptions should be considered when interpreting design performance. 
      They ensure internal consistency across all ~10⁵ simulations while producing 
      physically realistic inflow–outflow responses for feasibility screening and 
      cost-performance analysis.
    </p>


  <script>
    // ========= CONFIG =======================================================
    const DATA_URL = 'drain_lid_database.json';
    const LOGO_URL = 'drainlid_logo.png'; // leave '' if none

    // Hard-coded van Genuchten–Mualem parameters (Carsel & Parrish, 1988)
    // alpha [1/m], Ks_mm_per_h [mm/h], theta_r, theta_s [-]
    const SOIL_PROPS = {
      "Sand":             { theta_r: 0.045, theta_s: 0.43, alpha: 14.5, n: 2.68, Ks_mm_per_h: 297.0 },
      "Loamy Sand":       { theta_r: 0.057, theta_s: 0.41, alpha: 12.4, n: 2.28, Ks_mm_per_h: 145.8 },
      "Sandy Loam":       { theta_r: 0.065, theta_s: 0.41, alpha: 7.5,  n: 1.89, Ks_mm_per_h: 44.3  },
      "Loam":             { theta_r: 0.078, theta_s: 0.43, alpha: 3.6,  n: 1.56, Ks_mm_per_h: 10.4  },
      "Silt":             { theta_r: 0.034, theta_s: 0.46, alpha: 1.6,  n: 1.37, Ks_mm_per_h: 2.5   },
      "Silty Loam":       { theta_r: 0.067, theta_s: 0.45, alpha: 2.0,  n: 1.41, Ks_mm_per_h: 4.5   },
      "Sandy Clay Loam":  { theta_r: 0.100, theta_s: 0.39, alpha: 5.9,  n: 1.48, Ks_mm_per_h: 13.1 },
      "Clay Loam":        { theta_r: 0.095, theta_s: 0.41, alpha: 1.9,  n: 1.31, Ks_mm_per_h: 2.6   },
      "Silty Clay Loam":  { theta_r: 0.089, theta_s: 0.43, alpha: 1.0,  n: 1.23, Ks_mm_per_h: 0.7   },
      "Sandy Clay":       { theta_r: 0.100, theta_s: 0.38, alpha: 2.7,  n: 1.23, Ks_mm_per_h: 1.2   },
      "Silty Clay":       { theta_r: 0.070, theta_s: 0.36, alpha: 0.5,  n: 1.09, Ks_mm_per_h: 0.2   },
      "Clay":             { theta_r: 0.068, theta_s: 0.38, alpha: 0.8,  n: 1.09, Ks_mm_per_h: 0.6   }
    };

    // Custom Turbo-like colorscale for peak-flow reduction
    const TURBO_SCALE = [
      [0.00, '#30123b'],
      [0.15, '#4145ab'],
      [0.30, '#2c9df2'],
      [0.45, '#20c96b'],
      [0.60, '#8fd744'],
      [0.75, '#f6e620'],
      [0.90, '#fdae21'],
      [1.00, '#f1605d']
    ];

    // Metric configuration for the 3D design plots
    const METRIC_INFO = {
      eta_p_pct: {
        label: 'Peak flow reduction [%]',
        shortTitle: 'Peak flow reduction',
        colorscale: TURBO_SCALE,
        toColorValue: v => v
      },
      DetTime_min: {
        label: 'Detention time [h]',
        shortTitle: 'Detention time',
        colorscale: 'Viridis',
        toColorValue: v => v / 60.0 // min -> h
      },
      Delta_tp_min: {
        label: 'Time-to-peak delay [h]',
        shortTitle: 'Time-to-peak delay',
        colorscale: 'Cividis',
        toColorValue: v => v / 60.0 // min -> h
      },
      max_ponding: {
        label: 'Maximum ponding depth [m]',
        shortTitle: 'Maximum ponding depth',
        colorscale: 'Magma',
        toColorValue: v => v
      }
    };

    // Default cost parameters (per m² of LID / catchment)
    const COST_DEFAULTS = {
      cVol: 210,        // [$/m3]
      cSurf: 55,        // [$/m2]
      cOM: 6,           // [$/m2/yr]
      lifeYears: 30,    // [yr]
      discountRate: 0.03
    };

    function getHydroFilters() {
      const minEta = parseFloat(document.getElementById('min-eta-input')?.value);
      const minDetH = parseFloat(document.getElementById('min-det-h-input')?.value);
      const minDelayH = parseFloat(document.getElementById('min-delay-h-input')?.value);
      const maxPondM = parseFloat(document.getElementById('max-pond-m-input')?.value);

      return {
        minEta: isNaN(minEta) ? 0 : minEta,
        minDetH: isNaN(minDetH) ? 0 : minDetH,
        minDelayH: isNaN(minDelayH) ? 0 : minDelayH,
        maxPondM: isNaN(maxPondM) ? Infinity : maxPondM
      };
    }

    function getCostSettings() {
      const cVol = parseFloat(document.getElementById('c-vol-input')?.value);
      const cSurf = parseFloat(document.getElementById('c-surf-input')?.value);
      const cOM = parseFloat(document.getElementById('c-om-input')?.value);
      const lifeYears = parseFloat(document.getElementById('design-life-input')?.value);
      const discountRate = parseFloat(document.getElementById('discount-rate-input')?.value);

      return {
        cVol: isNaN(cVol) ? COST_DEFAULTS.cVol : cVol,
        cSurf: isNaN(cSurf) ? COST_DEFAULTS.cSurf : cSurf,
        cOM: isNaN(cOM) ? COST_DEFAULTS.cOM : cOM,
        lifeYears: isNaN(lifeYears) ? COST_DEFAULTS.lifeYears : lifeYears,
        discountRate: isNaN(discountRate) ? COST_DEFAULTS.discountRate : discountRate
      };
    }

    function getTpRange() {
      const tpMinEl = document.getElementById('tp-min-input');
      const tpMaxEl = document.getElementById('tp-max-input');

      let tpMin = parseFloat(tpMinEl?.value);
      let tpMax = parseFloat(tpMaxEl?.value);

      // Fallback to global range if inputs are empty/NaN
      if (isNaN(tpMin)) tpMin = globalTpMin;
      if (isNaN(tpMax)) tpMax = globalTpMax;

      // If still null (e.g. no data), just return as-is
      if (tpMin == null || tpMax == null) {
        return { tpMin, tpMax };
      }

      // Ensure tpMin <= tpMax
      if (tpMin > tpMax) {
        const tmp = tpMin;
        tpMin = tpMax;
        tpMax = tmp;
      }

      return { tpMin, tpMax };
    }


    // ========= GLOBAL STATE =================================================
    let dbMetrics = [];
    let QinHydro = null;   // [nSteps][nKeep]
    let QoutHydro = null;  // [nSteps][nKeep]
    let tMinutesHydro = null;
    let metricsByIdx = new Map();
    let currentSubset = [];
    let currentSoil = null;
    let currentPeff = null;
    let currentHydroScenario = null;
    let currentHydroData = null;
    let currentFeasibleSubset = [];
    let globalTpMin = null;
    let globalTpMax = null;

    let designPlotData = {
      eta_p_pct: null,
      DetTime_min: null,
      Delta_tp_min: null,
      max_ponding: null
    };

    let costPlotData = null;

    const METRIC_BUTTON_IDS = {
      eta_p_pct: 'btn-download-eta',
      DetTime_min: 'btn-download-det',
      Delta_tp_min: 'btn-download-dtp',
      max_ponding: 'btn-download-pond'
    };

    // ========= HELPERS ======================================================

    function mmToInch(mm) {
      return mm / 25.4;
    }

    function formatPeffLabel(mmVal) {
      const inch = mmToInch(mmVal);
      return `${mmVal.toFixed(1)} mm (${inch.toFixed(2)} in)`;
    }

    function setStatus(msg, isError = false) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = 'status' + (isError ? ' error' : '');
    }

    function updateSoilParamsLine(soilName) {
      const el = document.getElementById('soil-params');
      const p = SOIL_PROPS[soilName];

      if (!p) {
        el.textContent = soilName;
        return;
      }

      const dtheta = p.theta_s - p.theta_r;
      const Ks_mps = p.Ks_mm_per_h / 1000 / 3600; // mm/h -> m/s

      const tex =
        `${soilName} \\(\\; -\\; \\alpha = ${p.alpha.toFixed(2)}\\,\\mathrm{m}^{-1},` +
        `\\; n = ${p.n.toFixed(2)},` +
        `\\; \\Delta\\theta = ${dtheta.toFixed(3)},` +
        `\\; K_s = ${Ks_mps.toExponential(2)}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}\\)`;

      el.innerHTML = tex;
      if (window.MathJax && window.MathJax.typesetPromise) {
        MathJax.typesetPromise([el]).catch(() => {});
      }
    }

    function uniqueSortedNumeric(arr) {
      return Array.from(new Set(arr)).sort((a, b) => a - b);
    }

    // ========= HYDROGRAPH HANDLING =========================================

    function getHydroDataFromScenario(m) {
      if (!m || m.hydroIndex === undefined || m.hydroIndex < 0) return null;
      if (!QinHydro || !QoutHydro || !tMinutesHydro) return null;

      const col = m.hydroIndex; // 0-based column in QinHydro/QoutHydro
      const area = m.ATC_m2;
      if (!area || area <= 0) return null;

      const tHours = tMinutesHydro.map(v => v / 60.0);

      const inflow = QinHydro.map(row => {
        const q = row[col] || 0;
        return q / area * 1000 * 3600; // m3/s -> mm/h
      });

      const outflow = QoutHydro.map(row => {
        const q = row[col] || 0;
        return q / area * 1000 * 3600;
      });

      return { tHours, inflow, outflow };
    }

    function renderHydrographForScenario(m) {
      const div = document.getElementById('hydro-plot');
      const btn = document.getElementById('btn-download');

      // Case 1: no scenario at all (e.g. initial state)
      if (!m) {
        currentHydroScenario = null;
        currentHydroData = null;
        btn.disabled = true;

        const emptyData = [{
          x: [0],
          y: [0],
          mode: 'lines',
          line: { color: '#cccccc' },
          hoverinfo: 'skip',
          showlegend: false
        }];

        const layout = {
          title: 'Hydrographs — no scenario selected',
          margin: { l: 60, r: 10, t: 40, b: 45 },
          xaxis: {
            title: 'Time [h]',
            zeroline: false,
            showgrid: false,
            ticks: 'outside',
            tickwidth: 2,
            linewidth: 2,
            linecolor: '#000000'
          },
          yaxis: {
            title: 'Flux [mm/h]',
            zeroline: false,
            showgrid: false,
            ticks: 'outside',
            tickwidth: 2,
            linewidth: 2,
            linecolor: '#000000'
          },
          showlegend: false
        };

        Plotly.react(div, emptyData, layout, { responsive: true });
        document.getElementById('hydro-title').textContent =
          'Hydrographs — no scenario selected';
        return;
      }

      // Case 2: scenario exists but no stored hydrograph
      const hData = getHydroDataFromScenario(m);
      if (!hData) {
        currentHydroScenario = m;
        currentHydroData = null;
        btn.disabled = true;

        const emptyData = [{
          x: [0],
          y: [0],
          mode: 'lines',
          line: { color: '#cccccc' },
          hoverinfo: 'skip',
          showlegend: false
        }];

        const layout = {
          title: 'Hydrographs — no stored hydrograph data for this scenario',
          margin: { l: 60, r: 10, t: 40, b: 45 },
          xaxis: {
            title: 'Time [h]',
            zeroline: false,
            showgrid: false,
            ticks: 'outside',
            tickwidth: 2,
            linewidth: 2,
            linecolor: '#000000'
          },
          yaxis: {
            title: 'Flux [mm/h]',
            zeroline: false,
            showgrid: false,
            ticks: 'outside',
            tickwidth: 2,
            linewidth: 2,
            linecolor: '#000000'
          },
          showlegend: false
        };

        Plotly.react(div, emptyData, layout, { responsive: true });
        document.getElementById('hydro-title').textContent =
          'Hydrographs — no stored hydrograph data for this scenario';
        return;
      }

      // Case 3: full hydrograph is available
      currentHydroScenario = m;
      currentHydroData = hData;
      btn.disabled = false;

      const traceIn = {
        x: hData.tHours,
        y: hData.inflow,
        mode: 'lines',
        name: 'Inflow',
        line: { color: '#BC262D', width: 2.5, dash: 'dash' }
      };

      const traceOut = {
        x: hData.tHours,
        y: hData.outflow,
        mode: 'lines',
        name: 'Outflow',
        line: { color: '#0000A3', width: 2.5 }
      };

      const pond =
        (m.max_ponding !== undefined && m.max_ponding !== null)
          ? m.max_ponding.toFixed(3)
          : 'NA';

      const layout = {
        title:
          `Hydrographs — ${m.soilName}, ` +
          `area-ratio = ${(m.area_ratio * 100).toFixed(1)}%, ` +
          `LID depth = ${m.Ld_m.toFixed(2)} m, ` +
          `tp = ${m.tp_min.toFixed(1)} min, ` +
          `max ponding = ${pond} m`,
        margin: { l: 60, r: 10, t: 50, b: 45 },
        xaxis: {
          title: 'Time [h]',
          zeroline: false,
          showgrid: false,
          ticks: 'outside',
          tickwidth: 2,
          linewidth: 2,
          linecolor: '#000000'
        },
        yaxis: {
          title: 'Flux [mm/h]',
          zeroline: false,
          showgrid: false,
          ticks: 'outside',
          tickwidth: 2,
          linewidth: 2,
          linecolor: '#000000'
        },
        legend: {
          x: 0.02,
          y: 0.98,
          bgcolor: 'rgba(255,255,255,0.8)'
        }
      };

      Plotly.react(div, [traceIn, traceOut], layout, { responsive: true });
      document.getElementById('hydro-title').textContent =
        'Hydrographs — inflow and outflow (mm/h)';
    }

    function downloadCSVFile(filename, csv) {
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }


    function downloadCurrentHydroCSV() {
      if (!currentHydroScenario || !currentHydroData) return;

      const m = currentHydroScenario;
      const h = currentHydroData;
      const header = 'time_h,inflow_mmph,outflow_mmph\n';
      let rows = '';
      for (let i = 0; i < h.tHours.length; i++) {
        rows += `${h.tHours[i]},${h.inflow[i]},${h.outflow[i]}\n`;
      }
      const csv = header + rows;

      const soilSlug = m.soilName.replace(/\s+/g, '_');
      const fname =
        `hydrograph_${soilSlug}_AR${(m.area_ratio * 100).toFixed(1)}_Ld${m.Ld_m.toFixed(2)}.csv`;

      downloadCSVFile(fname, csv);
    }

    function downloadDesignCSV(metricName) {
      const info = METRIC_INFO[metricName];
      const data = designPlotData[metricName];
      if (!info || !data || !data.rows || !data.rows.length) return;

      const rows = data.rows;
      const metricLabel = info.label || metricName;

      let csv = 'idx,soil,Peff_mm,area_ratio,area_ratio_pct,LID_depth_m,tp_min_min,' +
                `${metricName}\n`;

      rows.forEach(r => {
        const arPct = r.area_ratio * 100.0;
        csv += [
          r.idx,
          JSON.stringify(r.soilName),
          r.Peff_mm,
          r.area_ratio,
          arPct.toFixed(3),
          r.Ld_m,
          r.tp_min,
          r.metricValue
        ].join(',') + '\n';
      });

      const soilSlug = (data.soil || 'soil').replace(/\s+/g, '_');
      const fname = `design_${metricName}_${soilSlug}_P${data.peff}.csv`;
      downloadCSVFile(fname, csv);
    }

    function downloadCostCSV() {
      if (!costPlotData || !costPlotData.rows || !costPlotData.rows.length) return;

      const rows = costPlotData.rows;

      // Header: geometry + all hydrologic metrics + cost
      let csv =
        'idx,soil,Peff_mm,' +
        'area_ratio,area_ratio_pct,' +
        'LID_depth_m,tp_min_min,' +
        'eta_p_pct,DetTime_h,Delta_tp_h,max_ponding_m,' +
        'NPV_per_m2_catch\n';

      rows.forEach(r => {
        const arPct = r.area_ratio * 100.0;
        csv += [
          r.idx,
          JSON.stringify(r.soilName),
          r.Peff_mm,
          r.area_ratio,
          arPct.toFixed(3),
          r.Ld_m,
          r.tp_min,
          r.eta_p_pct,
          r.DetTime_h,
          r.Delta_tp_h,
          r.max_ponding_m,
          r.npv_per_m2_catch
        ].join(',') + '\n';
      });

      const soilSlug = (costPlotData.soil || 'soil').replace(/\s+/g, '_');
      const fname = `cost_${soilSlug}_P${costPlotData.peff}.csv`;
      downloadCSVFile(fname, csv);
    }

    // ========= DESIGN PLOTS =================================================

    function buildDesignPlot(metricName, divId, subset, peffVal) {
      const info = METRIC_INFO[metricName];
      const div = document.getElementById(divId);
      const rowsForCSV = [];

      const x = [];
      const y = [];
      const z = [];
      const c = [];
      const custom = [];

      const xUn = [];
      const yUn = [];
      const zUn = [];
      const customUn = [];

      subset.forEach(m => {
        const xVal = m.area_ratio * 100.0; // percentage
        const yVal = m.Ld_m;
        const zVal = m.tp_min;
        const raw = m[metricName];
        
        // Store a CSV row for this scenario
        rowsForCSV.push({
          idx: m.idx,
          soilName: m.soilName,
          Peff_mm: m.Peff_catch_mm,
          area_ratio: m.area_ratio,
          Ld_m: m.Ld_m,
          tp_min: m.tp_min,
          metricName,
          metricValue: raw
        });

        if (raw === null || raw === undefined || isNaN(raw)) {
          xUn.push(xVal);
          yUn.push(yVal);
          zUn.push(zVal);
          customUn.push(m.idx);
        } else {
          x.push(xVal);
          y.push(yVal);
          z.push(zVal);
          c.push(info.toColorValue(raw));
          custom.push(m.idx);
        }
      });

      const cmin = c.length ? Math.min(...c) : 0;
      const cmax = c.length ? Math.max(...c) : 1;
      const peffLabel = formatPeffLabel(peffVal);

      const traceFeasible = {
        x, y, z,
        mode: 'markers',
        type: 'scatter3d',
        name: 'Feasible',
        customdata: custom,
        marker: {
          size: 5,
          color: c,
          colorscale: info.colorscale,
          cmin,
          cmax,
          showscale: true,
          colorbar: {
            title: {
              text: info.label,
              side: 'right'
            },
            thickness: 12,
            len: 0.9,
            outlinewidth: 2,
            ticks: 'inside'
          },
          line: {
            width: 1.5,
            color: 'rgba(0,0,0,0.7)'
          }
        },
        hovertemplate:
          'Area-ratio: %{x:.1f}%<br>' +
          'LID depth: %{y:.2f} m<br>' +
          't_p: %{z:.1f} min<br>' +
          `${info.label}: %{marker.color:.2f}<extra></extra>`
      };

      const traceUnfeasible = {
        x: xUn,
        y: yUn,
        z: zUn,
        mode: 'markers',
        type: 'scatter3d',
        name: 'Unfeasible / failed',
        customdata: customUn,
        marker: {
          size: 4,
          color: 'rgba(220,220,220,0.1)',
          showscale: false,
          line: {
            width: 1.3,
            color: 'rgba(80,80,80,0.7)'
          }
        },
        hovertemplate:
          'Area-ratio: %{x:.1f}%<br>' +
          'LID depth: %{y:.2f} m<br>' +
          't_p: %{z:.1f} min<br>' +
          '<b>Unfeasible / failed</b><extra></extra>'
      };

      // Compute global min/max to set full ranges (include feasible + unfeasible)
      const allX = x.concat(xUn);
      const allY = y.concat(yUn);
      const allZ = z.concat(zUn);

      let xRange = null, yRange = null, zRange = null;
      if (allX.length > 0) {
        const xMin = Math.min(...allX);
        const xMax = Math.max(...allX);
        const dx = (xMax - xMin) * 0.05 || 1;
        xRange = [xMin - dx, xMax + dx];
      }
      if (allY.length > 0) {
        const yMin = Math.min(...allY);
        const yMax = Math.max(...allY);
        const dy = (yMax - yMin) * 0.05 || 0.1;
        yRange = [yMin - dy, yMax + dy];
      }
      if (allZ.length > 0) {
        const zMin = Math.min(...allZ);
        const zMax = Math.max(...allZ);
        const dz = (zMax - zMin) * 0.05 || 1;
        zRange = [zMin - dz, zMax + dz];
      }

      const layout = {
        title: `${info.shortTitle} — ${currentSoil}, Pef = ${peffLabel}`,
        margin: { l: 0, r: 0, t: 40, b: 0 },
        scene: {
          xaxis: {
            title: 'Area-ratio [%]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            range: xRange || undefined
          },
          yaxis: {
            title: 'LID depth [m]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            range: yRange || undefined
          },
          zaxis: {
            title: 'Inflow time to peak [min]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            range: zRange || undefined
          },
          aspectmode: 'cube',
          camera: {
            eye: { x: 1.7, y: 1.7, z: 1.5 }
          }
        },
        showlegend: false
      };

      const data = [];
      if (x.length) data.push(traceFeasible);
      if (xUn.length) data.push(traceUnfeasible);

      Plotly.react(div, data, layout, { responsive: true });

      // Store data for CSV download
      designPlotData[metricName] = {
        soil: currentSoil,
        peff: peffVal,
        rows: rowsForCSV
      };

      // Enable / disable corresponding download button
      const btnId = METRIC_BUTTON_IDS[metricName];
      const btn = btnId ? document.getElementById(btnId) : null;
      if (btn) {
        btn.disabled = !rowsForCSV.length;
      }
      // Clicking on a point updates the hydrograph
      if (div && typeof div.on === 'function') {
        div.on('plotly_click', ev => {
          if (!ev.points || !ev.points.length) return;
          const idx = ev.points[0].customdata;
          if (idx === undefined || idx === null) return;
          const scenario = metricsByIdx.get(idx);
          if (!scenario) return;
          renderHydrographForScenario(scenario);
        });
      }
    }

    // ========= COST PLOT (per m² catchment) ================================

    function updateCostPlot() {
      const div = document.getElementById('cost-plot');
      const statusDiv = document.getElementById('cost-status');
      const titleDiv = document.getElementById('cost-title');

      if (!div || !statusDiv || !titleDiv) return;

      if (!dbMetrics.length || currentSoil === null || currentPeff === null) {
        Plotly.react(div, [], { title: '' }, { responsive: true });
        statusDiv.textContent = 'Select a soil and Pef to view cost–performance results.';
        titleDiv.textContent = 'Lifecycle cost — no feasible set yet';
        return;
      }

      const filters = getHydroFilters();
      const costSettings = getCostSettings();
      const { tpMin, tpMax } = getTpRange();

      // Present-value factor F(i,T)
      const i = costSettings.discountRate;
      const T = costSettings.lifeYears;
      const F = i > 0 ? (1 - Math.pow(1 + i, -T)) / i : T;

      // Filter currentSubset by hydrologic criteria
      currentFeasibleSubset = currentSubset.filter(m => {
        if (!m) return false;

        const eta   = m.eta_p_pct;
        const detH  = m.DetTime_min != null ? m.DetTime_min / 60.0 : NaN;
        const delayH = m.Delta_tp_min != null ? m.Delta_tp_min / 60.0 : NaN;
        const pond  = m.max_ponding;
        const Ld    = m.Ld_m;
        const ar    = m.area_ratio;   // dimensionless (0–1)
        const tp    = m.tp_min;       // [min]

        if (eta == null || isNaN(eta))   return false;
        if (detH == null || isNaN(detH)) return false;
        if (delayH == null || isNaN(delayH)) return false;
        if (pond == null || isNaN(pond)) return false;
        if (Ld == null || isNaN(Ld) || Ld <= 0) return false;
        if (ar == null || isNaN(ar) || ar <= 0) return false;
        if (tp == null || isNaN(tp)) return false;

        if (eta   < filters.minEta)      return false;
        if (detH  < filters.minDetH)     return false;
        if (delayH < filters.minDelayH)  return false;
        if (pond  > filters.maxPondM)    return false;

        // Enforce selected t_p range
        if (tpMin != null && tp < tpMin) return false;
        if (tpMax != null && tp > tpMax) return false;

        return true;
      });

      if (!currentFeasibleSubset.length) {
        Plotly.react(div, [], {
          title: `Lifecycle cost — no design meets current filters`,
          margin: { l: 60, r: 10, t: 50, b: 45 }
        }, { responsive: true });
        statusDiv.textContent =
          'No feasible design for this soil and Pef with the chosen hydrologic filters.';
        titleDiv.textContent = 'Lifecycle cost — no feasible set';
        return;
      }

      // Collapse feasible simulations to unique geometries (area_ratio + Ld_m)
      const geometryMap = new Map();
      currentFeasibleSubset.forEach(m => {
        const key = `${m.area_ratio}-${m.Ld_m}`;
        if (!geometryMap.has(key)) geometryMap.set(key, m);
      });
      const uniqueFeasible = Array.from(geometryMap.values());
      const uniqueCount = uniqueFeasible.length;

      // Compute cost PER UNIT CATCHMENT AREA for each unique feasible geometry
      const x = [];
      const y = [];
      const z = [];
      const custom = [];
      const rowsForCSV = [];

      let minCost = Infinity;
      let minIdx = -1;

      uniqueFeasible.forEach((m, k) => {
        const ar = m.area_ratio;
        const Ld = m.Ld_m;

        // Hydrologic metrics for this design
        const eta   = m.eta_p_pct;
        const detH  = m.DetTime_min != null ? m.DetTime_min / 60.0 : null;   // h
        const dtpH  = m.Delta_tp_min != null ? m.Delta_tp_min / 60.0 : null; // h
        const pond  = m.max_ponding;

        const capex_per_m2_catch =
          costSettings.cVol * ar * Ld +
          costSettings.cSurf * ar;

        const om_per_m2_catch =
          F * costSettings.cOM * ar;

        const npv_per_m2_catch = capex_per_m2_catch + om_per_m2_catch;

        x.push(ar * 100.0);
        y.push(Ld);
        z.push(npv_per_m2_catch);

        // customdata: [idx, eta, detH, dtpH, pond]
        custom.push([m.idx, eta, detH, dtpH, pond]);

        // Row for CSV: geometry + all metrics + cost
        rowsForCSV.push({
          idx: m.idx,
          soilName: m.soilName,
          Peff_mm: m.Peff_catch_mm,
          area_ratio: ar,
          Ld_m: Ld,
          tp_min: m.tp_min,          // [min]
          eta_p_pct: eta,            // [%]
          DetTime_h: detH,           // [h]
          Delta_tp_h: dtpH,          // [h]
          max_ponding_m: pond,       // [m]
          npv_per_m2_catch           // [$/m² catchment]
        });

        if (npv_per_m2_catch < minCost) {
          minCost = npv_per_m2_catch;
          minIdx = k;
        }
      });

      // Trace for all feasible designs
      const traceAll = {
        x, y, z,
        mode: 'markers',
        type: 'scatter3d',
        name: 'Feasible designs',
        customdata: custom,
        marker: {
          size: 5,
          color: z,
          colorscale: 'Viridis',
          showscale: true,
          colorbar: {
            title: { text: 'NPV [$/m²]', side: 'right' },
            thickness: 14,
            len: 0.8,
            outlinewidth: 2,
            ticks: 'inside',
            tickformat: '.0f'
          },
          line: {
            width: 1.2,
            color: 'rgba(0,0,0,0.6)'
          }
        },
        hovertemplate:
          'Area-ratio: %{x:.1f}%<br>' +
          'LID depth: %{y:.2f} m<br>' +
          'NPV cost: $%{z:.1f} per m² catchment<br>' +
          'Peak reduction η_p: %{customdata[1]:.1f} %<br>' +
          'Detention time: %{customdata[2]:.2f} h<br>' +
          'Time-to-peak delay: %{customdata[3]:.2f} h<br>' +
          'Max ponding depth: %{customdata[4]:.3f} m<extra></extra>'
      };

      // Highlight the minimum-cost design
      let traceMin = null;
      if (minIdx >= 0) {
        traceMin = {
          x: [x[minIdx]],
          y: [y[minIdx]],
          z: [z[minIdx]],
          mode: 'markers',
          type: 'scatter3d',
          name: 'Min cost',
          customdata: [custom[minIdx]],
          marker: {
            size: 7,
            symbol: 'diamond',
            color: 'red',
            line: { width: 2, color: 'black' }
          },
          hovertemplate:
            '<b>Minimum-cost design</b><br>' +
            'Area-ratio: %{x:.1f}%<br>' +
            'LID depth: %{y:.2f} m<br>' +
            'NPV cost: $%{z:.1f} per m² catchment<br>' +
            'Peak reduction η_p: %{customdata[1]:.1f} %<br>' +
            'Detention time: %{customdata[2]:.2f} h<br>' +
            'Time-to-peak delay: %{customdata[3]:.2f} h<br>' +
            'Max ponding depth: %{customdata[4]:.3f} m<extra></extra>'
        };
      }

      const peffLabel = formatPeffLabel(currentPeff);
      const layout = {
        title: `Lifecycle cost per catchment area — ${currentSoil}, Pef = ${peffLabel}`,
        margin: { l: 0, r: 0, t: 40, b: 0 },
        scene: {
          xaxis: {
            title: 'Area-ratio [%]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4
          },
          yaxis: {
            title: 'LID depth [m]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4
          },
          zaxis: {
            title: 'NPV cost [$/m² catchment]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4
          },
          aspectmode: 'cube',
          camera: {
            eye: { x: 1.7, y: 1.7, z: 1.5 }
          }
        },
        showlegend: true,
        legend: {
          x: 0.02,
          y: 0.98,
          bgcolor: 'rgba(255,255,255,0.8)',
          borderwidth: 0
        }
      };

      const data = traceMin ? [traceAll, traceMin] : [traceAll];

      Plotly.react(div, data, layout, { responsive: true });

      // Store data for CSV download
      costPlotData = {
        soil: currentSoil,
        peff: currentPeff,
        rows: rowsForCSV
      };
      const btnCost = document.getElementById('btn-download-cost');
      if (btnCost) btnCost.disabled = !rowsForCSV.length;

      // Clicking a cost point should also update the hydrograph
      if (div && typeof div.on === 'function') {
        div.on('plotly_click', ev => {
          if (!ev.points || !ev.points.length) return;
          const cd = ev.points[0].customdata;
          const idx = Array.isArray(cd) ? cd[0] : cd;  // first element of [idx, eta, detH, ...]
          if (idx === undefined || idx === null) return;
          const scenario = metricsByIdx.get(idx);
          if (!scenario) return;
          renderHydrographForScenario(scenario);
        });
      }

      // Update status text
      const best = uniqueFeasible[minIdx];
      if (best) {
        statusDiv.textContent =
          `Feasible designs (unique geometries): ${uniqueCount}. ` +
          `Underlying feasible simulations: ${currentFeasibleSubset.length}. ` +
          `Minimum NPV ≈ $${minCost.toFixed(1)} per m² of catchment at ` +
          `area-ratio ${(best.area_ratio * 100).toFixed(1)}% and ` +
          `LID depth ${best.Ld_m.toFixed(2)} m.`;
      } else {
        statusDiv.textContent =
          `Feasible designs (unique geometries): ${uniqueCount}. ` +
          `Underlying feasible simulations: ${currentFeasibleSubset.length}.`;
      }

      titleDiv.textContent =
        `Lifecycle cost per catchment area — ${currentSoil}, Pef = ${peffLabel}`;
    }

    // ========= UPDATE PLOTS & HYDRO ========================================

    function updatePlotsAndHydro() {
      if (!dbMetrics.length || currentSoil === null || currentPeff === null) return;

      currentSubset = dbMetrics.filter(m =>
        m.soilName === currentSoil &&
        m.Peff_catch_mm === currentPeff
      );

      buildDesignPlot('eta_p_pct',   'plot-eta',  currentSubset, currentPeff);
      buildDesignPlot('DetTime_min', 'plot-det',  currentSubset, currentPeff);
      buildDesignPlot('Delta_tp_min','plot-dtp',  currentSubset, currentPeff);
      buildDesignPlot('max_ponding','plot-pond', currentSubset, currentPeff);

      // Pick default scenario with hydroIndex >= 0 for current view
      let candidate = null;
      if (currentHydroScenario &&
          currentHydroScenario.soilName === currentSoil &&
          currentHydroScenario.Peff_catch_mm === currentPeff &&
          currentHydroScenario.hydroIndex !== undefined &&
          currentHydroScenario.hydroIndex >= 0) {
        candidate = currentHydroScenario;
      } else {
        candidate = currentSubset.find(
          m => m.hydroIndex !== undefined && m.hydroIndex >= 0
        ) || null;
      }
      renderHydrographForScenario(candidate);
      updateCostPlot();
    }

    // ========= UI INIT ======================================================

    function initUI() {
      const soilSel = document.getElementById('soil-select');
      const peffSel = document.getElementById('peff-select');
      const btnDownload = document.getElementById('btn-download');        // hydro CSV
      const btnEtaCSV   = document.getElementById('btn-download-eta');
      const btnDetCSV   = document.getElementById('btn-download-det');
      const btnDtpCSV   = document.getElementById('btn-download-dtp');
      const btnPondCSV  = document.getElementById('btn-download-pond');
      const btnCostCSV  = document.getElementById('btn-download-cost');

      const minEtaInput     = document.getElementById('min-eta-input');
      const minDetHInput    = document.getElementById('min-det-h-input');
      const minDelayHInput  = document.getElementById('min-delay-h-input');
      const maxPondMInput   = document.getElementById('max-pond-m-input');
      const tpMinInput      = document.getElementById('tp-min-input');
      const tpMaxInput      = document.getElementById('tp-max-input');
      const cVolInput       = document.getElementById('c-vol-input');
      const cSurfInput      = document.getElementById('c-surf-input');
      const cOMInput        = document.getElementById('c-om-input');
      const lifeInput       = document.getElementById('design-life-input');
      const discRateInput   = document.getElementById('discount-rate-input');


      if (!soilSel || !peffSel) return;

      // Soils: start with sandy → clayey ordering
      const soilNames = Array.from(new Set(dbMetrics.map(m => m.soilName)));
      const sortedSoils = soilNames.slice().sort((a, b) => a.localeCompare(b));
      const sandyFirst = sortedSoils.sort((a, b) => {
        const sandyA = /sand/i.test(a);
        const sandyB = /sand/i.test(b);
        if (sandyA && !sandyB) return -1;
        if (!sandyA && sandyB) return 1;
        return a.localeCompare(b);
      });

      soilSel.innerHTML = '';
      sandyFirst.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        soilSel.appendChild(opt);
      });

      btnDownload.addEventListener('click', downloadCurrentHydroCSV);

      btnEtaCSV?.addEventListener('click', () => downloadDesignCSV('eta_p_pct'));
      btnDetCSV?.addEventListener('click', () => downloadDesignCSV('DetTime_min'));
      btnDtpCSV?.addEventListener('click', () => downloadDesignCSV('Delta_tp_min'));
      btnPondCSV?.addEventListener('click', () => downloadDesignCSV('max_ponding'));
      btnCostCSV?.addEventListener('click', () => downloadCostCSV());

      const replotCost = () => updateCostPlot();

      minEtaInput?.addEventListener('change', replotCost);
      minDetHInput?.addEventListener('change', replotCost);
      minDelayHInput?.addEventListener('change', replotCost);
      maxPondMInput?.addEventListener('change', replotCost);

      // NEW: t_p range inputs
      if (tpMinInput && tpMaxInput) {
        if (globalTpMin != null && globalTpMax != null) {
          tpMinInput.value = globalTpMin.toFixed(1);
          tpMaxInput.value = globalTpMax.toFixed(1);
        }
        tpMinInput.addEventListener('change', replotCost);
        tpMaxInput.addEventListener('change', replotCost);
      }

      cVolInput?.addEventListener('change', replotCost);
      cSurfInput?.addEventListener('change', replotCost);
      cOMInput?.addEventListener('change', replotCost);
      lifeInput?.addEventListener('change', replotCost);
      discRateInput?.addEventListener('change', replotCost);

      // Initial empty cost plot
      updateCostPlot();

      currentSoil = sandyFirst[0] || null;
      soilSel.value = currentSoil;

      // Peff options for current soil
      function refreshPeffOptions() {
        const filtered = dbMetrics.filter(m => m.soilName === currentSoil);
        const peffs = uniqueSortedNumeric(filtered.map(m => m.Peff_catch_mm));

        peffSel.innerHTML = '';
        peffs.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v;
          opt.textContent = formatPeffLabel(v);
          peffSel.appendChild(opt);
        });

        // choose default Pef closest to 25.4 mm (≈ 1 inch)
        const targetMm = 25.4;
        if (peffs.length > 0) {
          let best = peffs[0];
          let bestDiff = Math.abs(peffs[0] - targetMm);
          for (let i = 1; i < peffs.length; i++) {
            const diff = Math.abs(peffs[i] - targetMm);
            if (diff < bestDiff) {
              bestDiff = diff;
              best = peffs[i];
            }
          }
          currentPeff = best;
          peffSel.value = String(best);
        } else {
          currentPeff = null;
        }
      }

      refreshPeffOptions();
      soilSel.disabled = false;
      peffSel.disabled = false;

      updateSoilParamsLine(currentSoil);
      updatePlotsAndHydro();

      soilSel.addEventListener('change', () => {
        currentSoil = soilSel.value;
        updateSoilParamsLine(currentSoil);
        const filtered = dbMetrics.filter(m => m.soilName === currentSoil);
        const peffs = uniqueSortedNumeric(filtered.map(m => m.Peff_catch_mm));
        peffSel.innerHTML = '';
        peffs.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v;
          opt.textContent = formatPeffLabel(v);
          peffSel.appendChild(opt);
        });
        currentPeff = peffs[0] || null;
        if (currentPeff !== null) peffSel.value = String(currentPeff);
        updatePlotsAndHydro();
      });

      peffSel.addEventListener('change', () => {
        currentPeff = parseFloat(peffSel.value);
        updatePlotsAndHydro();
      });
    }

    // ========= DATA LOADING =================================================

    async function loadData() {
      try {
        setStatus('Loading data…');
        const resp = await fetch(DATA_URL, { cache: 'no-cache' });
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status} while fetching ${DATA_URL}`);
        }
        const raw = await resp.json();

        dbMetrics = raw.metrics || [];
        if (!Array.isArray(dbMetrics) || !dbMetrics.length) {
          throw new Error('No "metrics" array in JSON.');
        }

        // Compute global tp_min range across all metrics
        const tpVals = dbMetrics
          .map(m => m.tp_min)
          .filter(v => v !== null && v !== undefined && !isNaN(v));
        if (tpVals.length) {
          globalTpMin = Math.min(...tpVals);
          globalTpMax = Math.max(...tpVals);
        }

        QinHydro = raw.Qin_all || null;
        QoutHydro = raw.Qout_all || null;
        tMinutesHydro = raw.t_minutes || null;


        // Build idx map
        metricsByIdx.clear();
        dbMetrics.forEach(m => {
          if (m.idx === undefined) return;
          metricsByIdx.set(m.idx, m);
        });

        setStatus('Data loaded. Use the controls to explore the design space.');
        initUI();
      } catch (err) {
        console.error(err);
        setStatus(`Error loading data: ${err.message}`, true);
      }
    }

    // ========= BOOTSTRAP ====================================================

    document.addEventListener('DOMContentLoaded', () => {
      // Logo insertion
      if (LOGO_URL) {
        const box = document.getElementById('logo-box');
        if (box) {
          const img = document.createElement('img');
          img.src = LOGO_URL;
          img.alt = 'DRAIN-LID logo';
          box.appendChild(img);
        }
      }

      loadData();
    });
  </script>
</body>
</html>

