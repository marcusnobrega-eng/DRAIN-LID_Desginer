<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DRAIN-LID Design Performance Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <!-- MathJax v2 (compatible with Plotly for LaTeX in labels) -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: { inlineMath: [['\\(','\\)'], ['$', '$']] },
      SVG: { font: "TeX" }
    });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_SVG"></script>

  <style>
    :root {
      --bg: #ffffff;
      --fg: #222222;
      --accent: #1f77b4;
      --muted: #777777;
      --border: #dddddd;
      --panel-bg: #f8f8f8;
      --font-main: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, Helvetica, Arial, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 1.5rem;
      font-family: var(--font-main);
      background: var(--bg);
      color: var(--fg);
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 0.5rem;
    }

    .header-left h1 {
      font-size: 1.6rem;
      margin: 0 0 0.25rem 0;
    }

    .header-left h2 {
      font-size: 1.1rem;
      margin: 0;
      color: var(--muted);
    }

    .header-right img {
      max-height: 60px;
      width: auto;
    }

    #soil-params {
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
      color: var(--muted);
    }

    #soil-params strong {
      color: var(--fg);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 1rem;
      margin-bottom: 0.5rem;
      background: var(--panel-bg);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      min-width: 180px;
    }

    .control-group label {
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
      color: var(--muted);
    }

    select {
      padding: 0.35rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      font-size: 0.9rem;
      background: #fff;
      cursor: pointer;
    }

    select:disabled {
      background: #f0f0f0;
      cursor: not-allowed;
      color: #aaaaaa;
    }

    .plots-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    .plot3d {
      flex: 1 1 300px;
      min-width: 300px;
      height: 420px;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
    }

    #hydro-plot {
      width: 100%;
      height: 380px;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      margin-bottom: 0.4rem;
    }

    #download-csv {
      padding: 0.4rem 0.8rem;
      font-size: 0.85rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      background: #f0f0f5;
      cursor: pointer;
    }

    #download-csv:disabled {
      background: #f5f5f5;
      color: #aaaaaa;
      cursor: not-allowed;
    }

    .status {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .status.error {
      color: #b00020;
    }

    .legend-note,
    .method-note {
      margin-top: 0.4rem;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .method-note strong {
      color: var(--fg);
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    @media (max-width: 900px) {
      .plot3d {
        height: 360px;
      }
    }
  </style>
</head>
<body>
  <div class="container">

    <div class="header-row">
      <div class="header-left">
        <h1>DRAIN-LID Design Performance Explorer</h1>
        <h2>Interactive design-space visualization from the DRAIN-LID database</h2>
      </div>
      <div class="header-right">
        <!-- Put your logo file (e.g., drainlid_logo.png) in the same folder -->
        <img id="drainlid-logo" src="drainlid_logo.png" alt="DRAIN-LID logo" />
      </div>
    </div>

    <div id="soil-params">
      <!-- Filled dynamically with van Genuchten parameters -->
    </div>

    <div class="controls">
      <div class="control-group">
        <label for="soil-select">Soil type</label>
        <select id="soil-select" disabled></select>
      </div>

      <div class="control-group">
        <label for="peff-select">Effective precipitation, \(P_{\mathrm{eff}}\)</label>
        <select id="peff-select" disabled></select>
      </div>
    </div>

    <div class="plots-row">
      <div id="plot-eta" class="plot3d"></div>
      <div id="plot-det" class="plot3d"></div>
      <div id="plot-dtp" class="plot3d"></div>
    </div>

    <div id="hydro-plot"></div>
    <button id="download-csv" disabled>Download hydrograph as CSV</button>

    <div id="status" class="status">
      Loading data…
    </div>
    <div class="legend-note">
      Axes in 3D plots: area-ratio [%] (ratio between LID footprint and upstream catchment area),
      media depth \(L_{d}\) [m], and time to peak \(t_{p}\) [min].  
      Click any point in the 3D plots to visualize its inflow and outflow hydrographs
      (stored only for scenarios with intermediate peak flow reduction).
    </div>

    <div class="method-note">
      This interactive explorer was developed by <strong>Marcus N. Gomes Jr., PhD</strong>.
      Scenario ensembles are generated by coupling a mixed-form Richards equation solver
      (with van Genuchten–Mualem parameters from Carsel &amp; Parrish) to a Nash-type
      inflow hydrograph. Designs span combinations of soil type, media depth, effective
      precipitation, area-ratio ( \(A_{\mathrm{TC}}/A_{\mathrm{up}}\) ), and time to peak, allowing
      systematic assessment of bioretention hydrologic performance.
    </div>
  </div>

  <script>
    // === CONFIG ==============================================================

    const DATA_URL = 'drain_lid_database.json';  // must be in the same folder as index.html

    // Metric metadata (plain-text labels; no LaTeX here to avoid issues in titles/colorbars)
    const METRIC_INFO = {
      eta_p_pct: {
        label: 'Peak flow reduction',
        colorbarTitle: 'Peak reduction [%]',
        shortLabel: 'Peak red. [%]'
      },
      DetTime_min: {
        label: 'Detention time',
        colorbarTitle: 'Detention [h]',
        shortLabel: 'Detention [h]'
      },
      Delta_tp_min: {
        label: 'Time-to-peak delay',
        colorbarTitle: 'Time-to-peak delay [h]',
        shortLabel: 'Δt_p [h]'
      }
    };

    // Preferred soil order: sandy -> clayey
    const SOIL_ORDER = [
      'Sand',
      'Loamy Sand',
      'Sandy Loam',
      'Loam',
      'Silt',
      'Silty Loam',
      'Sandy Clay Loam',
      'Clay Loam',
      'Silty Clay Loam',
      'Sandy Clay',
      'Silty Clay',
      'Clay'
    ];

    // Van Genuchten parameter table (Carsel & Parrish style)
    // Units:
    //   theta_r, theta_s: [-]
    //   alpha: [1/m]
    //   n: [-]
    //   Ks_mm_per_h: [mm/h]
    const SOIL_VG = {
      'Sand': {theta_r: 0.045, theta_s: 0.43, alpha: 14.5, n: 2.68, Ks_mm_per_h: 297.0},
      'Loamy Sand': {theta_r: 0.057, theta_s: 0.41, alpha: 12.4, n: 2.28, Ks_mm_per_h: 145.8},
      'Sandy Loam': {theta_r: 0.065, theta_s: 0.41, alpha: 7.5, n: 1.89, Ks_mm_per_h: 44.3},
      'Loam': {theta_r: 0.078, theta_s: 0.43, alpha: 3.6, n: 1.56, Ks_mm_per_h: 10.4},
      'Silt': {theta_r: 0.034, theta_s: 0.46, alpha: 1.6, n: 1.37, Ks_mm_per_h: 2.5},
      'Silty Loam': {theta_r: 0.067, theta_s: 0.45, alpha: 2.0, n: 1.41, Ks_mm_per_h: 4.5},
      'Sandy Clay Loam': {theta_r: 0.100, theta_s: 0.39, alpha: 5.9, n: 1.48, Ks_mm_per_h: 13.1},
      'Clay Loam': {theta_r: 0.095, theta_s: 0.41, alpha: 1.9, n: 1.31, Ks_mm_per_h: 2.6},
      'Silty Clay Loam': {theta_r: 0.089, theta_s: 0.43, alpha: 1.0, n: 1.23, Ks_mm_per_h: 0.70},
      'Sandy Clay': {theta_r: 0.100, theta_s: 0.38, alpha: 2.7, n: 1.23, Ks_mm_per_h: 1.20},
      'Silty Clay': {theta_r: 0.070, theta_s: 0.36, alpha: 0.5, n: 1.09, Ks_mm_per_h: 0.20},
      'Clay': {theta_r: 0.068, theta_s: 0.38, alpha: 0.8, n: 1.09, Ks_mm_per_h: 2.00}
    };

    // === GLOBAL STATE ========================================================

    let dbMetrics = [];   // full flat array of metric objects
    let QinMatrix = [];   // [nSteps x nKeep] in m^3/s
    let QoutMatrix = [];  // [nSteps x nKeep] in m^3/s
    let tMinutes = [];    // [nSteps] in minutes

    let soilList = [];
    let peffList = [];

    let lastHydrograph = null;   // store last plotted hydrograph for CSV export

    // === HELPERS =============================================================

    function uniqueSorted(arr) {
      return Array.from(new Set(arr)).sort((a, b) => {
        if (typeof a === 'string') return a.localeCompare(b);
        return a - b;
      });
    }

    function sortSoilsPreferred(list) {
      // Use SOIL_ORDER first, then any unknown soils alphabetically at the end
      return list.slice().sort((a, b) => {
        const ia = SOIL_ORDER.indexOf(a);
        const ib = SOIL_ORDER.indexOf(b);
        if (ia === -1 && ib === -1) {
          return a.localeCompare(b);
        } else if (ia === -1) {
          return 1;
        } else if (ib === -1) {
          return -1;
        } else {
          return ia - ib;
        }
      });
    }

    function mmToInch(mm) {
      return mm / 25.4;
    }

    function formatPeffLabel(mmVal) {
      const inch = mmToInch(mmVal);
      return `${mmVal.toFixed(1)} mm (${inch.toFixed(2)} in)`;
    }

    function setStatus(msg, isError = false) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = 'status' + (isError ? ' error' : '');
    }

    function typesetMathJax() {
      if (window.MathJax && window.MathJax.Hub) {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
      }
    }

    function updateSoilParamsDisplay() {
      const soilSel = document.getElementById('soil-select');
      const soil = soilSel.value;
      const box = document.getElementById('soil-params');

      const vg = SOIL_VG[soil];
      if (!vg) {
        box.innerHTML = `<strong>${soil}</strong> — van Genuchten parameters not available.`;
        typesetMathJax();
        return;
      }

      const dtheta = vg.theta_s - vg.theta_r;
      const Ks_m_s = vg.Ks_mm_per_h / 3.6e6; // mm/h -> m/s

      box.innerHTML =
        `<strong>${soil}</strong> &mdash; ` +
        `\\(\\alpha = ${vg.alpha.toFixed(2)}\\,\\mathrm{m}^{-1}\\), ` +
        `\\(n = ${vg.n.toFixed(2)}\\), ` +
        `\\(\\Delta\\theta = ${dtheta.toFixed(3)}\\), ` +
        `\\(K_{\\mathrm{s}} = ${Ks_m_s.toExponential(2)}\\,\\mathrm{m\\,s^{-1}}\\)`;
      typesetMathJax();
    }

    // === UI INIT =============================================================

    function initUI() {
      const soilSel  = document.getElementById('soil-select');
      const peffSel  = document.getElementById('peff-select');

      // 1. Populate soil list (sandy -> clayey)
      soilList = uniqueSorted(dbMetrics.map(m => m.soilName));
      soilList = sortSoilsPreferred(soilList);

      soilSel.innerHTML = '';
      soilList.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        soilSel.appendChild(opt);
      });

      // 2. Populate Peff list for the first soil
      updatePeffOptions();

      // Enable selects now that data is loaded
      soilSel.disabled = soilList.length === 0;
      peffSel.disabled = peffList.length === 0;

      // Show VG parameters for initial soil
      updateSoilParamsDisplay();

      // Event listeners
      soilSel.addEventListener('change', () => {
        updatePeffOptions();
        updateSoilParamsDisplay();
        updateAllPlots();
      });

      peffSel.addEventListener('change', () => {
        updateAllPlots();
      });

      // CSV button
      document.getElementById('download-csv')
        .addEventListener('click', downloadHydrographCSV);

      // First plot
      updateAllPlots();
    }

    function updatePeffOptions() {
      const soilSel = document.getElementById('soil-select');
      const peffSel = document.getElementById('peff-select');

      const soil = soilSel.value;

      const filtered = dbMetrics.filter(m => m.soilName === soil);
      peffList = uniqueSorted(filtered.map(m => m.Peff_catch_mm));

      peffSel.innerHTML = '';
      peffList.forEach(val => {
        const opt = document.createElement('option');
        opt.value = val;
        opt.textContent = formatPeffLabel(val);
        peffSel.appendChild(opt);
      });

      if (peffList.length > 0) {
        peffSel.value = peffList[0];
        peffSel.disabled = false;
      } else {
        peffSel.disabled = true;
      }

      typesetMathJax();
    }

    // === PLOTTING: 3D DESIGN SPACE ==========================================

    function updateAllPlots() {
      if (!dbMetrics || dbMetrics.length === 0) {
        setStatus('No data loaded.', true);
        return;
      }

      const soilSel = document.getElementById('soil-select');
      const peffSel = document.getElementById('peff-select');

      const soil  = soilSel.value;
      const peff  = parseFloat(peffSel.value);

      if (!soil || isNaN(peff)) {
        setStatus('Select a soil type and an effective precipitation.', true);
        return;
      }

      const peffLabel = formatPeffLabel(peff);

      // Update three plots, one per metric
      buildMetricPlot('eta_p_pct', 'plot-eta', soil, peff, peffLabel);
      buildMetricPlot('DetTime_min', 'plot-det', soil, peff, peffLabel);
      buildMetricPlot('Delta_tp_min', 'plot-dtp', soil, peff, peffLabel);

      setStatus(
        `Soil: ${soil} | P_eff: ${peffLabel}. Click a point to view its hydrograph (if stored).`
      );
    }

    function buildMetricPlot(metricName, divId, soil, peff, peffLabel) {
      const metricInfo = METRIC_INFO[metricName] || METRIC_INFO.eta_p_pct;

      // Select colorscale by metric (Plasma, Viridis, Cividis)
      let colorscale = 'Plasma';
      if (metricName === 'DetTime_min') {
        colorscale = 'Viridis';
      } else if (metricName === 'Delta_tp_min') {
        colorscale = 'Cividis';
      }

      const subset = dbMetrics.filter(m =>
        m.soilName === soil &&
        m.Peff_catch_mm === peff
      );

      const plotDiv = document.getElementById(divId);

      if (subset.length === 0) {
        Plotly.react(plotDiv, [], {
          title: {
            text: `${metricInfo.label} — ${soil}, P_eff = ${peffLabel} (no data)`,
            font: { size: 14 }
          },
          margin: {l: 0, r: 0, t: 40, b: 0}
        });
        if (plotDiv.on) plotDiv.on('plotly_click', handlePointClick);
        typesetMathJax();
        return;
      }

      // x = area_ratio [%], y = Ld [m], z = tp [min]
      const x = []; const y = []; const z = [];
      const c = []; const customFeasible = [];
      const x_unf = []; const y_unf = []; const z_unf = []; const customUnf = [];

      subset.forEach(m => {
        const ar_percent = m.area_ratio * 100.0;
        const Ld = m.Ld_m;
        const tp = m.tp_min;
        let val = m[metricName];

        // Convert detention time and Δt_p to hours for color scaling
        if ((metricName === 'DetTime_min' || metricName === 'Delta_tp_min') &&
            val != null && !isNaN(val)) {
          val = val / 60.0;
        }

        if (val == null || isNaN(val)) {
          x_unf.push(ar_percent);
          y_unf.push(Ld);
          z_unf.push(tp);
          customUnf.push(m.idx);
        } else {
          x.push(ar_percent);
          y.push(Ld);
          z.push(tp);
          c.push(val);
          customFeasible.push(m.idx);
        }
      });

      let cmin = 0, cmax = 1;
      if (c.length > 0) {
        cmin = Math.min(...c);
        cmax = Math.max(...c);
        if (cmin === cmax) cmax = cmin + 1e-6;
      }

      const traceFeasible = {
        x: x,
        y: y,
        z: z,
        mode: 'markers',
        type: 'scatter3d',
        name: 'Feasible',
        customdata: customFeasible,
        marker: {
          size: 6,
          color: c,
          colorscale: colorscale,
          cmin: cmin,
          cmax: cmax,
          showscale: true,
          colorbar: {
            title: metricInfo.colorbarTitle,
            titleside: 'right',
            ticks: 'inside',
            ticklen: 6,
            tickwidth: 1.5,
            outlinewidth: 2,
            thickness: 10,   // thinner colorbar
            len: 0.75        // shorter colorbar
          },
          line: {
            width: 1.5,
            color: 'rgba(0,0,0,0.7)'
          }
        },
        hovertemplate:
          'Area-ratio: %{x:.1f}%<br>' +
          'L_d: %{y:.2f} m<br>' +
          't_p: %{z:.1f} min<br>' +
          metricInfo.shortLabel + ': %{marker.color:.2f}<extra></extra>'
      };

      const traceUnfeasible = {
        x: x_unf,
        y: y_unf,
        z: z_unf,
        mode: 'markers',
        type: 'scatter3d',
        name: 'Unfeasible / No metric',
        customdata: customUnf,
        marker: {
          size: 5,
          color: 'rgba(200,200,200,0.25)',
          showscale: false,
          line: {
            width: 1.5,
            color: 'rgba(80,80,80,0.7)'
          }
        },
        hovertemplate:
          'Area-ratio: %{x:.1f}%<br>' +
          'L_d: %{y:.2f} m<br>' +
          't_p: %{z:.1f} min<br>' +
          '<b>No metric / unfeasible</b><extra></extra>'
      };

      const metricTitle = metricInfo.label;
      const layout = {
        title: {
          text: `${metricTitle} — ${soil}, P_eff = ${peffLabel}`,
          font: { size: 15 }
        },
        scene: {
          xaxis: {
            title: 'Area-ratio [%]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            tickwidth: 2,
            linecolor: '#000',
            linewidth: 2
          },
          yaxis: {
            title: 'Media depth, $L_d$ [m]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            tickwidth: 2,
            linecolor: '#000',
            linewidth: 2
          },
          zaxis: {
            title: 'Time to peak, $t_p$ [min]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            tickwidth: 2,
            linecolor: '#000',
            linewidth: 2
          },
          aspectmode: 'cube',
          camera: {
            eye: {x: 1.7, y: 1.7, z: 1.7},
            center: {x: 0, y: 0, z: 0},
            up: {x: 0, y: 0, z: 1}
          }
        },
        margin: {l: 0, r: 0, t: 50, b: 0},
        legend: {
          x: 0.02,
          y: 0.98,
          bgcolor: 'rgba(255,255,255,0.8)'
        }
      };

      const data = [];
      if (x.length > 0) data.push(traceFeasible);
      if (x_unf.length > 0) data.push(traceUnfeasible);

      Plotly.react(plotDiv, data, layout, {responsive: true}).then(() => {
        if (plotDiv.on) {
          plotDiv.on('plotly_click', handlePointClick);
        }
        typesetMathJax();
      });
    }

    // === HYDROGRAPH PLOTTING ================================================

    function handlePointClick(event) {
      if (!event || !event.points || event.points.length === 0) return;

      const pt = event.points[0];
      const idx = pt.customdata;

      if (idx === undefined || idx === null) {
        setStatus('Clicked point has no associated scenario index.', true);
        return;
      }

      const scen = dbMetrics.find(m => m.idx === idx);

      if (!scen) {
        setStatus(`No scenario found with idx = ${idx}.`, true);
        return;
      }

      const hIndex = scen.hydroIndex;

      if (hIndex === undefined || hIndex === null || hIndex < 0) {
        setStatus('No hydrograph stored for this scenario (outside selected performance band).', true);
        Plotly.react('hydro-plot', [], {
          title: {
            text: 'No hydrograph available for this scenario',
            font: { size: 14 }
          },
          margin: {l: 50, r: 10, t: 40, b: 40}
        });
        document.getElementById('download-csv').disabled = true;
        lastHydrograph = null;
        return;
      }

      plotHydrograph(scen, hIndex);
    }

    function plotHydrograph(scen, hIndex) {
      if (!Array.isArray(QinMatrix) || QinMatrix.length === 0 ||
          !Array.isArray(QoutMatrix) || QoutMatrix.length === 0 ||
          !Array.isArray(tMinutes) || tMinutes.length === 0) {
        setStatus('Hydrograph time-series arrays are not available.', true);
        return;
      }

      const nSteps = tMinutes.length;
      const qInSeries = [];
      const qOutSeries = [];

      for (let i = 0; i < nSteps; i++) {
        const rowIn  = QinMatrix[i];
        const rowOut = QoutMatrix[i];
        const qIn  = rowIn  ? rowIn[hIndex]  : 0;
        const qOut = rowOut ? rowOut[hIndex] : 0;
        qInSeries.push(qIn || 0);
        qOutSeries.push(qOut || 0);
      }

      const tHours = tMinutes.map(v => v / 60.0);

      const ATC = scen.ATC_m2;
      if (!ATC || ATC <= 0) {
        setStatus('Invalid LID area (ATC_m2) for this scenario.', true);
        return;
      }

      const factor = 1000.0 * 3600.0 / ATC;  // m^3/s → mm/h over ATC

      const qIn_mm_h  = qInSeries.map(v => v * factor);
      const qOut_mm_h = qOutSeries.map(v => v * factor);

      const traceIn = {
        x: tHours,
        y: qIn_mm_h,
        mode: 'lines',
        name: 'Inflow',
        line: { width: 2, color: '#BC262D', dash: 'dash' }
      };

      const traceOut = {
        x: tHours,
        y: qOut_mm_h,
        mode: 'lines',
        name: 'Outflow',
        line: { width: 2, color: '#0000A3' }
      };

      const title =
        'Hydrographs — ' + scen.soilName +
        ', P_eff = ' + formatPeffLabel(scen.Peff_catch_mm) +
        ', area-ratio = ' + (scen.area_ratio * 100).toFixed(1) + '% ' +
        ', $L_d$ = ' + scen.Ld_m.toFixed(2) + '\\,\\mathrm{m}, ' +
        '$t_p$ = ' + scen.tp_min.toFixed(1) + '\\,\\mathrm{min}';

      const layout = {
        title: { text: title, font: { size: 14 } },
        xaxis: {
          title: 'Time [h]',
          zeroline: false,
          showgrid: false,
          ticks: 'outside',
          ticklen: 6,
          tickwidth: 2,
          linecolor: '#000',
          linewidth: 2
        },
        yaxis: {
          title: 'Flux [mm/h]',
          zeroline: false,
          showgrid: false,
          ticks: 'outside',
          ticklen: 6,
          tickwidth: 2,
          linecolor: '#000',
          linewidth: 2
        },
        margin: {l: 60, r: 10, t: 60, b: 50},
        legend: {
          x: 0.01,
          y: 0.99,
          bgcolor: 'rgba(255,255,255,0.8)'
        }
      };

      Plotly.react('hydro-plot', [traceIn, traceOut], layout, {responsive: true})
        .then(() => {
          typesetMathJax();
        });

      const eta = scen.eta_p_pct;
      setStatus(
        `Hydrograph for scenario idx=${scen.idx}, soil=${scen.soilName}, ` +
        `P_eff=${formatPeffLabel(scen.Peff_catch_mm)}, ` +
        `peak reduction = ${eta !== undefined ? eta.toFixed(1) : 'NA'}%.`
      );

      // Store for CSV export
      lastHydrograph = {
        tHours,
        qIn_mm_h,
        qOut_mm_h,
        scen
      };
      document.getElementById('download-csv').disabled = false;
    }

    function downloadHydrographCSV() {
      if (!lastHydrograph) {
        alert('No hydrograph has been plotted yet.');
        return;
      }

      const { tHours, qIn_mm_h, qOut_mm_h, scen } = lastHydrograph;
      let csv = 'time_h,inflow_mm_h,outflow_mm_h\n';

      for (let i = 0; i < tHours.length; i++) {
        csv += `${tHours[i].toFixed(4)},${qIn_mm_h[i].toFixed(6)},${qOut_mm_h[i].toFixed(6)}\n`;
      }

      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');

      const soilSafe = (scen.soilName || 'soil').replace(/[^a-z0-9]+/gi, '_');
      const fname = `hydrograph_${soilSafe}_Peff${scen.Peff_catch_mm.toFixed(1)}mm_ratio${(scen.area_ratio*100).toFixed(1)}.csv`;

      a.href = url;
      a.download = fname;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // === DATA LOADING ========================================================

    async function loadData() {
      try {
        setStatus('Loading data…');

        const resp = await fetch(DATA_URL, {cache: 'no-cache'});
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status} while fetching ${DATA_URL}`);
        }
        const raw = await resp.json();

        dbMetrics  = raw.metrics || raw.Metrics || [];
        QinMatrix  = raw.Qin_all || [];
        QoutMatrix = raw.Qout_all || [];
        tMinutes   = raw.t_minutes || raw.tMinutes || [];

        if (!Array.isArray(dbMetrics) || dbMetrics.length === 0) {
          throw new Error('No "metrics" array found in JSON or it is empty.');
        }

        setStatus('Data loaded. Use the controls above to explore the design space and click points for hydrographs.');
        initUI();
      } catch (err) {
        console.error(err);
        setStatus(`Error loading data: ${err.message}`, true);
        alert('Could not load drain_lid_database.json. Check the console for more details.');
      }
    }

    // Kick things off
    loadData();
  </script>
</body>
</html>
