<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DRAIN-LID Design Performance Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <!-- MathJax for LaTeX in normal HTML text (NOT inside Plotly axes) -->
  <script>
    window.PlotlyConfig = { MathJaxConfig: 'local' };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
          id="MathJax-script"></script>

  <style>
    :root {
      --bg: #ffffff;
      --fg: #222222;
      --accent: #1f77b4;
      --muted: #777777;
      --border: #dddddd;
      --panel-bg: #f8f8f8;
      --font-main: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, Helvetica, Arial, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 1.5rem;
      font-family: var(--font-main);
      background: var(--bg);
      color: var(--fg);
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.75rem;
    }

    h1 {
      font-size: 1.7rem;
      margin: 0 0 0.25rem 0;
    }

    h2 {
      font-size: 1.0rem;
      margin: 0;
      color: var(--muted);
      font-weight: 400;
    }

    .logo-container img {
      max-height: 70px;
    }

    .soil-params {
      font-size: 0.95rem;
      color: var(--fg);
      margin-bottom: 0.8rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 0.9rem 1rem;
      margin-bottom: 1rem;
      background: var(--panel-bg);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      min-width: 190px;
    }

    .control-group label {
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
      color: var(--muted);
    }

    select {
      padding: 0.35rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      font-size: 0.9rem;
      background: #fff;
      cursor: pointer;
    }

    select:disabled {
      background: #f0f0f0;
      cursor: not-allowed;
      color: #aaaaaa;
    }

    .plots-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.75rem;
      margin-bottom: 1.0rem;
    }

    .plot-panel {
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      overflow: hidden;
      min-height: 360px;
    }

    .plot-panel-title {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid var(--border);
      background: #fafafa;
    }

    .plot-div {
      width: 100%;
      height: 340px;
    }

    #hydro-panel {
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      margin-bottom: 1rem;
      overflow: hidden;
    }

    #hydro-header {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid var(--border);
      background: #fafafa;
    }

    #hydro-plot {
      width: 100%;
      height: 320px;
    }

    .status {
      margin-top: 0.4rem;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .status.error {
      color: #b00020;
    }

    .legend-note {
      margin-top: 0.4rem;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .method-note {
      margin-top: 1.0rem;
      padding: 0.75rem 1rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: #fafafa;
      font-size: 0.9rem;
      line-height: 1.45;
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    button.export-btn {
      margin-left: auto;
      margin-right: 0.75rem;
      margin-top: 0.35rem;
      padding: 0.25rem 0.6rem;
      font-size: 0.85rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: white;
      cursor: pointer;
    }

    button.export-btn:hover {
      background: #f2f2f2;
    }

    @media (max-width: 1050px) {
      .plots-row {
        grid-template-columns: 1fr;
      }
      .plot-div {
        height: 320px;
      }
      #hydro-plot {
        height: 260px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>DRAIN-LID Design Performance Explorer</h1>
        <h2>Interactive design-space visualization from the DRAIN-LID database</h2>
      </div>
      <div class="logo-container">
        <!-- Put your DRAIN-LID logo file here (same folder) -->
        <img src="drain_lid_logo.png" alt="DRAIN-LID logo" />
      </div>
    </header>

    <div id="soil-params" class="soil-params">
      <!-- Filled by JS with LaTeX (MathJax) for the selected soil -->
    </div>

    <div class="controls">
      <div class="control-group">
        <label for="soil-select">Soil type</label>
        <select id="soil-select" disabled></select>
      </div>

      <div class="control-group">
        <label for="peff-select">Effective precipitation, \(P_{\mathrm{eff}}\)</label>
        <select id="peff-select" disabled></select>
      </div>
    </div>

    <div class="plots-row">
      <div class="plot-panel">
        <div class="plot-panel-title" id="title-eta">
          Peak flow reduction
        </div>
        <div id="plot-eta" class="plot-div"></div>
      </div>

      <div class="plot-panel">
        <div class="plot-panel-title" id="title-det">
          Detention time
        </div>
        <div id="plot-det" class="plot-div"></div>
      </div>

      <div class="plot-panel">
        <div class="plot-panel-title" id="title-dtp">
          Time-to-peak delay
        </div>
        <div id="plot-dtp" class="plot-div"></div>
      </div>
    </div>

    <div id="hydro-panel">
      <div id="hydro-header">
        Hydrographs
        <button id="export-csv" class="export-btn" type="button">Export CSV</button>
      </div>
      <div id="hydro-plot"></div>
    </div>

    <div id="status" class="status">
      Loading data…
    </div>

    <div class="legend-note">
      Axes in the 3D panels: area-ratio [%] (dimensionless design ratio), media depth
      \(L_d\) [m], and time-to-peak \(t_p\) [min]. Points with gray outlines correspond
      to simulations where no performance metric is available (e.g., infeasible design).
    </div>

    <div class="method-note">
      This interactive viewer was developed by <strong>Marcus N. Gomes Jr., PhD</strong>.
      Each point in the design space corresponds to a full mixed-form Richards equation
      simulation of an infiltration LID system, varying media depth \(L_d\), area-ratio,
      and hydrograph time-to-peak \(t_p\). The <em>area-ratio</em> is defined as the
      ratio between the LID footprint area and the upstream contributing area, i.e.
      \( \text{area-ratio} = A_{\mathrm{TC}} / A_{\mathrm{up}} \).
    </div>
  </div>

  <script>
    // ========================================================================
    // CONFIG
    // ========================================================================

    const DATA_URL = 'drain_lid_database.json';

    // Soil hydraulic parameters for header (C&P 1988-style values)
    // Units: alpha [1/m], Ks [m/s], dtheta = theta_s - theta_r [-]
    const SOIL_PARAMS = {
      'Sand':            { alpha: 14.5, n: 2.68, dtheta: 0.43 - 0.045, Ks: 8.25e-5 },
      'Loamy Sand':      { alpha: 12.4, n: 2.28, dtheta: 0.41 - 0.057, Ks: 4.05e-5 },
      'Sandy Loam':      { alpha:  7.5, n: 1.89, dtheta: 0.41 - 0.065, Ks: 1.23e-5 },
      'Loam':            { alpha:  3.6, n: 1.56, dtheta: 0.43 - 0.078, Ks: 2.89e-6 },
      'Silt':            { alpha:  1.6, n: 1.37, dtheta: 0.46 - 0.034, Ks: 6.94e-7 },
      'Silty Loam':      { alpha:  2.0, n: 1.41, dtheta: 0.45 - 0.067, Ks: 1.25e-6 },
      'Sandy Clay Loam': { alpha:  5.9, n: 1.48, dtheta: 0.39 - 0.100, Ks: 3.64e-6 },
      'Clay Loam':       { alpha:  1.9, n: 1.31, dtheta: 0.41 - 0.095, Ks: 7.22e-7 },
      'Silty Clay Loam': { alpha:  1.0, n: 1.23, dtheta: 0.43 - 0.089, Ks: 1.94e-7 },
      'Sandy Clay':      { alpha:  2.7, n: 1.23, dtheta: 0.38 - 0.100, Ks: 3.33e-7 },
      'Silty Clay':      { alpha:  0.5, n: 1.09, dtheta: 0.36 - 0.070, Ks: 5.56e-8 },
      'Clay':            { alpha:  0.8, n: 1.09, dtheta: 0.38 - 0.068, Ks: 5.56e-7 }
    };

    // Metric configuration
    const METRIC_CONFIG = {
      eta_p_pct: {
        key: 'eta_p_pct',
        label: 'Peak flow reduction',
        colorbarTitle: 'Peak reduction [%]',
        colorscale: 'Turbo'  // <-- as requested
      },
      DetTime_h: {
        key: 'DetTime_h',
        label: 'Detention time',
        colorbarTitle: 'Detention [h]',
        colorscale: 'Viridis'
      },
      Delta_tp_h: {
        key: 'Delta_tp_h',
        label: 'Time-to-peak delay',
        colorbarTitle: 'Time-to-peak delay [h]',
        colorscale: 'Cividis'
      }
    };

    // ========================================================================
    // GLOBAL STATE
    // ========================================================================

    let dbMetrics = [];   // full array of metric objects from JSON
    let soilList = [];
    let peffList = [];

    // The subset used in the current view (for exporting / hydrograph)
    let currentSubset = [];
    let currentHydroScenario = null;
    let currentHydroIndex = null;

    // ========================================================================
    // HELPERS
    // ========================================================================

    function uniqueSorted(arr) {
      return Array.from(new Set(arr)).sort((a, b) => {
        if (typeof a === 'string') return a.localeCompare(b);
        return a - b;
      });
    }

    function mmToInch(mm) {
      return mm / 25.4;
    }

    function formatPeffLabel(mmVal) {
      const inch = mmToInch(mmVal);
      return `${mmVal.toFixed(1)} mm (${inch.toFixed(2)} in)`;
    }

    function setStatus(msg, isError = false) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = 'status' + (isError ? ' error' : '');
    }

    function updateSoilHeader(soilName) {
      const params = SOIL_PARAMS[soilName];
      const el = document.getElementById('soil-params');

      if (!params) {
        el.innerHTML = soilName
          ? `Soil: <strong>${soilName}</strong>`
          : '';
        MathJax.typesetPromise();
        return;
      }

      const { alpha, n, dtheta, Ks } = params;

      el.innerHTML =
        `${soilName} — ` +
        `\\( \\alpha = ${alpha.toFixed(2)}\\,\\text{m}^{-1}, \\)` +
        `\\( n = ${n.toFixed(2)}, \\)` +
        `\\( \\Delta\\theta = ${dtheta.toFixed(3)}, \\)` +
        `\\( K_s = ${Ks.toExponential(2)}\\,\\text{m s}^{-1} \\)`;

      MathJax.typesetPromise();
    }

    // ========================================================================
    // UI INIT
    // ========================================================================

    function initUI() {
      const soilSel = document.getElementById('soil-select');
      const peffSel = document.getElementById('peff-select');

      // 1. Soil list from metrics
      soilList = uniqueSorted(dbMetrics.map(m => m.soilName));

      soilSel.innerHTML = '';
      soilList.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        soilSel.appendChild(opt);
      });

      // Prefer Sand as default if present
      if (soilList.includes('Sand')) {
        soilSel.value = 'Sand';
      } else if (soilList.length > 0) {
        soilSel.selectedIndex = 0;
      }

      // 2. Populate Peff for the initial soil
      updatePeffOptions();

      soilSel.disabled = soilList.length === 0;
      peffSel.disabled = peffList.length === 0;

      soilSel.addEventListener('change', () => {
        updatePeffOptions();
        updatePlots();
      });

      peffSel.addEventListener('change', () => {
        updatePlots();
      });

      // Initial header for soil parameters
      if (soilSel.value) {
        updateSoilHeader(soilSel.value);
      }

      // First full plot + default hydrograph
      updatePlots();
    }

    function updatePeffOptions() {
      const soilSel = document.getElementById('soil-select');
      const peffSel = document.getElementById('peff-select');

      const soil = soilSel.value;

      const filtered = dbMetrics.filter(m => m.soilName === soil);
      peffList = uniqueSorted(filtered.map(m => m.Peff_catch_mm));

      peffSel.innerHTML = '';
      peffList.forEach(val => {
        const opt = document.createElement('option');
        opt.value = val;
        opt.textContent = formatPeffLabel(val);
        peffSel.appendChild(opt);
      });

      if (peffList.length > 0) {
        peffSel.value = peffList[0];
        peffSel.disabled = false;
      } else {
        peffSel.disabled = true;
      }
    }

    // ========================================================================
    // PLOTTING — 3D DESIGN PLOTS
    // ========================================================================

    function buildMetricPlot(containerId, subset, metricKey, cfg, soil, peff) {
      const container = document.getElementById(containerId);
      if (!container) return;

      // Prepare arrays
      const x = [];          // area-ratio [%]
      const y = [];          // Ld [m]
      const z = [];          // tp [min]
      const c = [];          // metric (for color)

      const xUnf = [];
      const yUnf = [];
      const zUnf = [];

      const customdata = [];      // index in subset for feasible
      const customdataUnf = [];   // index in subset for unfeasible

      subset.forEach((m, idx) => {
        const arPercent = m.area_ratio * 100.0;
        const Ld = m.Ld_m;
        const tp = m.tp_min;
        const val = m[metricKey];

        if (val == null || isNaN(val)) {
          xUnf.push(arPercent);
          yUnf.push(Ld);
          zUnf.push(tp);
          customdataUnf.push(idx);
        } else {
          x.push(arPercent);
          y.push(Ld);
          z.push(tp);
          c.push(val);
          customdata.push(idx);
        }
      });

      let zMin = c.length ? Math.min(...c) : 0;
      let zMax = c.length ? Math.max(...c) : 1;
      if (zMin === zMax) {
        zMin -= 0.5;
        zMax += 0.5;
      }

      const traceFeasible = {
        x,
        y,
        z,
        customdata,
        mode: 'markers',
        type: 'scatter3d',
        name: 'Feasible',
        marker: {
          size: 6,
          color: c,
          colorscale: cfg.colorscale,   // Turbo / Viridis / Cividis
          cmin: zMin,
          cmax: zMax,
          colorbar: {
            title: cfg.colorbarTitle,
            titleside: 'right',
            thickness: 10,
            ticks: 'inside',
            ticklen: 5,
            tickwidth: 1.0,
            outlinewidth: 2
          },
          line: {
            width: 1.4,
            color: 'rgba(0,0,0,0.7)'
          }
        },
        hovertemplate:
          'Area-ratio: %{x:.1f} %<br>' +
          'L_d: %{y:.2f} m<br>' +
          't_p: %{z:.1f} min<br>' +
          cfg.colorbarTitle + ': %{marker.color:.2f}<extra></extra>'
      };

      const traceUnfeasible = {
        x: xUnf,
        y: yUnf,
        z: zUnf,
        customdata: customdataUnf,
        mode: 'markers',
        type: 'scatter3d',
        name: 'Unfeasible / no metric',
        marker: {
          size: 5,
          color: 'rgba(220,220,220,0.2)',
          line: {
            width: 1.4,
            color: 'rgba(90,90,90,0.8)'
          }
        },
        hovertemplate:
          'Area-ratio: %{x:.1f} %<br>' +
          'L_d: %{y:.2f} m<br>' +
          't_p: %{z:.1f} min<br>' +
          '<b>No metric (infeasible / filtered)</b><extra></extra>'
      };

      const data = [];
      if (x.length > 0) data.push(traceFeasible);
      if (xUnf.length > 0) data.push(traceUnfeasible);

      const peffLabel = formatPeffLabel(peff);

      const layout = {
        margin: { l: 0, r: 0, t: 10, b: 0 },
        scene: {
          xaxis: {
            title: 'Area-ratio [%]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            tickwidth: 1.2
          },
          yaxis: {
            title: 'Media depth, L<sub>d</sub> [m]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            tickwidth: 1.2
          },
          zaxis: {
            title: 'Time to peak, t<sub>p</sub> [min]',
            zeroline: false,
            showgrid: true,
            gridcolor: '#e0e0e0',
            ticks: 'outside',
            ticklen: 4,
            tickwidth: 1.2
          },
          camera: {
            eye: { x: 1.4, y: 1.4, z: 1.1 }
          }
        },
        showlegend: false
      };

      const titleElId = {
        'plot-eta': 'title-eta',
        'plot-det': 'title-det',
        'plot-dtp': 'title-dtp'
      }[containerId];

      if (titleElId) {
        const titleEl = document.getElementById(titleElId);
        if (titleEl) {
          titleEl.textContent =
            `${cfg.label} — ${soil}, P_eff = ${peffLabel}`;
        }
      }

      Plotly.react(containerId, data, layout, { responsive: true })
        .then(() => {
          // Click -> hydrograph
          container.on('plotly_click', ev => {
            if (!ev.points || ev.points.length === 0) return;
            const p = ev.points[0];
            const idx = p.customdata;
            if (idx == null) return;
            const scen = subset[idx];
            currentHydroScenario = scen;
            currentHydroIndex = idx;
            plotHydrograph(scen, idx);
          });
        });
    }

    // ========================================================================
    // PLOTTING — HYDROGRAPH
    // ========================================================================

    function plotHydrograph(scen, indexInSubset) {
      if (!scen) {
        clearHydrograph();
        return;
      }

      // These names must match the JSON fields you stored.
      // Adjust here if your JSON uses slightly different keys.
      const t = scen.t_hours_24 || scen.t_hours || null;
      const Qin = scen.Qin_mmph || scen.Qin_mm_per_h || null;
      const Qout = scen.Qout_mmph || scen.Qout_mm_per_h || null;

      const hydroDiv = document.getElementById('hydro-plot');
      const header = document.getElementById('hydro-header');

      if (!t || !Qin || !Qout || t.length === 0) {
        header.textContent =
          'Hydrographs — no stored hydrograph data for this scenario';
        Plotly.react(hydroDiv, [], {
          margin: { l: 60, r: 10, t: 40, b: 50 },
          xaxis: { title: 'Time [h]' },
          yaxis: { title: 'Flux [mm/h]' }
        });
        return;
      }

      const title =
        'Hydrographs — ' + scen.soilName +
        ', P_eff = ' + formatPeffLabel(scen.Peff_catch_mm) +
        ', area-ratio = ' + (scen.area_ratio * 100).toFixed(1) + '% ' +
        ', L_d = ' + scen.Ld_m.toFixed(2) + ' m, ' +
        't_p = ' + scen.tp_min.toFixed(1) + ' min';

      header.textContent = title;

      const traceIn = {
        x: t,
        y: Qin,
        mode: 'lines',
        name: 'Inflow',
        line: {
          width: 2.2,
          dash: 'dash',
          color: '#BC262D'
        }
      };

      const traceOut = {
        x: t,
        y: Qout,
        mode: 'lines',
        name: 'Outflow',
        line: {
          width: 2.2,
          color: '#0000A3'
        }
      };

      const layout = {
        margin: { l: 60, r: 10, t: 20, b: 50 },
        xaxis: {
          title: 'Time [h]',
          zeroline: false,
          showgrid: false,
          ticks: 'outside',
          ticklen: 5,
          tickwidth: 1.4
        },
        yaxis: {
          title: 'Flux [mm/h]',
          zeroline: false,
          showgrid: false,
          ticks: 'outside',
          ticklen: 5,
          tickwidth: 1.4
        },
        legend: {
          x: 0.02,
          y: 0.98
        }
      };

      Plotly.react(hydroDiv, [traceIn, traceOut], layout, { responsive: true });
    }

    function clearHydrograph() {
      const hydroDiv = document.getElementById('hydro-plot');
      const header = document.getElementById('hydro-header');
      header.textContent = 'Hydrographs';
      Plotly.react(hydroDiv, [], {
        margin: { l: 60, r: 10, t: 40, b: 50 },
        xaxis: { title: 'Time [h]' },
        yaxis: { title: 'Flux [mm/h]' }
      });
    }

    // ========================================================================
    // CSV EXPORT
    // ========================================================================

    function exportCurrentHydrographCSV() {
      if (!currentHydroScenario) {
        alert('No hydrograph is currently selected.');
        return;
      }

      const scen = currentHydroScenario;
      const t = scen.t_hours_24 || scen.t_hours || null;
      const Qin = scen.Qin_mmph || scen.Qin_mm_per_h || null;
      const Qout = scen.Qout_mmph || scen.Qout_mm_per_h || null;

      if (!t || !Qin || !Qout || t.length === 0) {
        alert('No hydrograph data stored for this scenario.');
        return;
      }

      let csv = 'time_h,Qin_mm_per_h,Qout_mm_per_h\n';
      for (let i = 0; i < t.length; i++) {
        csv += `${t[i]},${Qin[i]},${Qout[i]}\n`;
      }

      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'drain_lid_hydrograph.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    document.getElementById('export-csv')
      .addEventListener('click', exportCurrentHydrographCSV);

    // ========================================================================
    // MAIN UPDATE
    // ========================================================================

    function updatePlots() {
      if (!dbMetrics || dbMetrics.length === 0) {
        setStatus('No data loaded.', true);
        return;
      }

      const soilSel = document.getElementById('soil-select');
      const peffSel = document.getElementById('peff-select');

      const soil = soilSel.value;
      const peff = parseFloat(peffSel.value);

      updateSoilHeader(soil);

      // Subset for soil + Peff
      currentSubset = dbMetrics.filter(m =>
        m.soilName === soil && m.Peff_catch_mm === peff
      );

      // Add hour-based metrics for plotting colors
      currentSubset.forEach(m => {
        m.DetTime_h = (m.DetTime_min != null && !isNaN(m.DetTime_min))
          ? m.DetTime_min / 60.0
          : null;
        m.Delta_tp_h = (m.Delta_tp_min != null && !isNaN(m.Delta_tp_min))
          ? m.Delta_tp_min / 60.0
          : null;
      });

      if (currentSubset.length === 0) {
        setStatus('No scenarios found for this combination.', true);
        clearHydrograph();
        ['plot-eta', 'plot-det', 'plot-dtp'].forEach(id => {
          Plotly.react(id, [], {});
        });
        return;
      }

      // Build the three 3D plots
      buildMetricPlot('plot-eta', currentSubset, 'eta_p_pct',
                      METRIC_CONFIG.eta_p_pct, soil, peff);
      buildMetricPlot('plot-det', currentSubset, 'DetTime_h',
                      METRIC_CONFIG.DetTime_h, soil, peff);
      buildMetricPlot('plot-dtp', currentSubset, 'Delta_tp_h',
                      METRIC_CONFIG.Delta_tp_h, soil, peff);

      // Default hydrograph: first scenario in subset with hydro data, or first
      let defaultScenario = null;
      for (let i = 0; i < currentSubset.length; i++) {
        const s = currentSubset[i];
        const t = s.t_hours_24 || s.t_hours || null;
        const Qin = s.Qin_mmph || s.Qin_mm_per_h || null;
        const Qout = s.Qout_mmph || s.Qout_mm_per_h || null;
        if (t && Qin && Qout && t.length > 0) {
          defaultScenario = { scen: s, idx: i };
          break;
        }
      }
      if (!defaultScenario) {
        defaultScenario = { scen: currentSubset[0], idx: 0 };
      }

      currentHydroScenario = defaultScenario.scen;
      currentHydroIndex = defaultScenario.idx;
      plotHydrograph(defaultScenario.scen, defaultScenario.idx);

      const peffLabel = formatPeffLabel(peff);
      setStatus(`Soil: ${soil} | P_eff: ${peffLabel} | Scenarios: ${currentSubset.length}`);
    }

    // ========================================================================
    // DATA LOADING
    // ========================================================================

    async function loadData() {
      try {
        setStatus('Loading data…');

        const resp = await fetch(DATA_URL, { cache: 'no-cache' });
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status} while fetching ${DATA_URL}`);
        }
        const raw = await resp.json();

        dbMetrics = Array.isArray(raw)
          ? raw
          : (raw.metrics || raw.Metrics || []);

        if (!Array.isArray(dbMetrics) || dbMetrics.length === 0) {
          throw new Error('No "metrics" array found in JSON.');
        }

        setStatus('Data loaded. Use the controls to explore the design space.');
        initUI();
      } catch (err) {
        console.error(err);
        setStatus(`Error loading data: ${err.message}`, true);
        alert('Could not load drain_lid_database.json. Check the console for details.');
      }
    }

    loadData();
  </script>
</body>
</html>
